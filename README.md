<!-- Конспект по обучению реакту -->
<!-- npx create-react-app react-app -->
<!-- Ctrl+D -Выделить следующую такую же выделенную конструкцию -->
<!-- Тэги не требующие закрытия в html в jsx нужно зарывать так <tag />. Наример : <input />  -->
<!-- Чтобы передать пропсы не в виде строки, то вместо "" оборачиваем это в {}. Это работает с любыми типами данных -->
<!-- 						<PizzaBlock title="Туапсинская" price="700"/>  число передастся в виде строки-->
<!-- 						<PizzaBlock title="Краснодарская" price={800}/> число передастся в виде числа-->

<!-- Так как props - это объект. Чтобы сократить код, можно не обращаясь к props, доставать из него price, а просто прописать в {} price, но для этого нужно вытащить все элементы из props на этапе объявления функционального компонетна (декструктуризация пропса). Для этого в фигурных скобках, описываем вытаскиваемые элементы -->

    <!-- 				<div class="pizza-block__price">от {price} ₽</div>
    			 			<div class="pizza-block__price">от {props.price} ₽</div>  -->

<!-- function PizzaBlock({ title, price }) {}
	// function PizzaBlock(props) {} -->

<!-- Деструктуризация объекта. Простейший пример -->
<!--
 const obj={a:1,b:2,c:3};
const a = obj.a
const b = obj.b
const c = obj.c
console.log(a,b,c)
 -->
<!--
const {a,b,c}={a:1,b:2,c:3};
console.log(a,b,c)
 -->
 <!-- Эти 2 блока кода выше делают одно и то же -->

<!-- В jsx нужно писать className, вместо class в html -->
<!--  свойства svg картинок, которые обычно пишутся через - , в jsx пишутся через camelCase (stroke-width => strokeWidth) -->

<!-- хуки - это функции внутри react -->
<!-- Чтобы использовать хук в файле, нужно импортировать его из библиотеки react. Вот так: -->
<!-- import React, { useState } from 'react' -->
<!-- Если нам нужно записать данные в переменную, которые мы захотим потом изменить, и при этом эти данные должны отрисовываться на странице - то нужно использовать хук-useState. Если данные не будут меняться - не используем этот хук -->
<!-- Хук заставляет браузер не просто хранить данные в переменной, а заново рендерить данные, в случае их изменений -->

<!-- Вебпак по умолчанию считает что мы находимся в папке public, когда пишем путь к картинкам -->
<!-- Чтобы использовать файлы, находящиеся НЕ ВНУТРИ папки public, нужно их импортировать в тот компонент, где мы хотим их использовать. Например import logo from "../logo.svg". Соответсвтенно путь прописываем относительно компонента -->

<!-- Если мы рендерим список, то каждый элемент массива внутри map должен иметь уникальный (внутри этого массива) ключ (указывается ключ внутри открывающего родительского тэга). Для статичных массивов можно использовать индекс.
Для динамических - id, или что-то кроме индекса. Если не указывать явно key, то по умолчанию будет использован индекс.
 -->

<!-- {types.map((type, index) => {
return (

<li
key = {type}
onClick={() => onClickType(index)}
className={activeType === index ? 'active' : ''} >
{typeNames[type]}
</li>
);
})} -->

<!-- Чтобы не хранить большие объемы данных на фронте, данные для приложения принято запрашивать с сервера. Мы делаем запрос на бэк с определенными параметрами, бэк шарится по своей базе и собирает нам ответы с параметрами, которые мы задали в пакет, потом отправляет нам собранный пакет. -->

<!-- https://mockapi.io/ -->
<!-- Сервис. Предоставляет сервер, для хранения серверных данных, для бэка. Подходит только для пет проектов. -->

<!-- Чтобы воспользоваться скелетоном нужно установить библиотеку react-content-loader -->
<!-- npm i react-content-loader -->

<!-- Ставим реакт роутер -->
<!-- npm install react-router-dom localforage match-sorter sort-by -->
<!-- Чтобы наглядно применить реакт роутер разделим приложение на части и положим эти части в папку pages -->
<!-- Не забываем подправить пути к импортам после разбивки на части -->

<!-- Сейчас принято использовать css модули. Это когда каждый компонент имеет свой собственный файл css. БЭМ при этом не нужен, достигается инкапсуляция стилей, нет конфликтов классов. Перед расширением указываем префикс module.[ext] -->

<!-- Делаем функционал сортировки и фильтрации пицц. При выборе каждой категории должны отображаться только соответсвтующие ей пиццы. При выборе критерия сортироки, результаты выстраиваются по убыванию или возрастанию по выбранному критерию.-->
<!-- Делать мы это будем путем изменения запроса на сервер, чтобы он нам по условию возвращал json с отфильтрованными и отсортированными данными. Смотри документацию mockapi.io -->

<!-- Сортировка -->

<!-- Вот наш обычный запрос массива пицц с бэкенда -->
<!-- https://64845cf9ee799e3216269459.mockapi.io/items -->

<!-- А вот запрос с сортировкой -->
<!-- https://64845cf9ee799e3216269459.mockapi.io/items?sortBy=price&order=asc -->

<!-- Где ? - знак уточнения запроса. Что дальше идут searchParams -->
<!-- sortBy (sortby,orderBy,orderby) - параметры поиска, которые сортируют элементы. Например: sortBy=price - сортировка по полю (свойству) price. -->
<!-- order - параметр , отвечающий за то, сортировать по возрастанию (acs) или убыванию (desc) -->

<!-- Можно через searchParams:
const url = new URL(https://64845cf9ee799e3216269459.mockapi.io/items)
url.searchParams.append('sortBy', 'price');
url.searchParams.append('order', 'asc');
-->

<!-- Фильтрация.Фильтрация реализована с помощью параметров поиска -->
<!-- Запрос с фильтрацией -->
<!-- https://64845cf9ee799e3216269459.mockapi.io/items?filter=Пепперони&order=asc -->
<!-- Где по параметру filter=Пепперони (или search=Пепперони) нам вернутся все элементы, соответствующие строке "Пепперони" в любом из полей -->

<!-- https://64845cf9ee799e3216269459.mockapi.io/items?rating=4 -->
<!-- Если мы хотим Получить все элементы, у которых значение поля (свойства) rating, совпадает с 4-->

<!-- Нам нужно как-то передавать параметры фильтрации и сортировки в  -->
<!-- В jsx родитель элемента не может получить сведения о стейтах (States) дочерних элементов. Но зато можно разместить States, необходимые для дочерних элементов внутри родителя и передавать их внутрь дочерних элементов как параметры -->
<!-- Делаем все в Home.jsx и Categories.jsx -->

<!-- Теперь Sort.jsx -->
<!-- Для начала делаем все то же самое, что и раньше, но теперь нужно прикрутить логику, что если выбираем "популярности"- сортировать по полю rating, "цене" - по полю price, "алфавиту" - title. -->

<!-- В обычном реакте можно передавать пропы только от родителя к дочерним компонентам, причем нужно это делать по цепочке, передавая их с 1 уровня на второй, со второго на третий и т.д. Если таких промежуточных элементов больше одного, то эта ситуация называется props drilling и ее следует избегать с помощью React context-->
<!-- Для того чтобы выполнять какие-либо действия по изменению инпута в реакте существуют контролируемые инпуты (controlled inputs), по событию они возвращают event, но не простой, а обернутый логикой реакта. synteticBaseEvent. И из него можно вытаскивать все те же свойства, что и из обычного инпута-->

<!-- Для начала сделаем фильтрацию пицц при помощи js -->
<!-- Потом сделаем фильтрация при помощи бэкенда через useEffect -->

<!-- Делаем пагинацию -->

<!-- Ставим библиотеку для пагинации -->
<!-- npm install react-paginate --save -->

<!-- ============================================================================================================= -->

<!-- React Context -->

<!-- Кстати ReactRouter и Redux использует React Context -->

<!-- React Context предоставляет возможность обращаться и прокидывать пропсы напрямую от одного компонента к другому. (Помогает избежать Props Drilling ) Покажем как он работает на примере поиска. -->
<!-- Полное описание как использовать context -->
<!-- Создаем объект context в App.jsx. т.к. он является общим родителем для компонента Search.jsx и Home.jsx.  -->
<!-- const SearchContext = React.createContext(); -->
<!-- Объект SearchContext содержит в себе компоненты Consumer и Provider -->
<!-- Подобно тому как мы оборачивали все наше приложение в ReactRouter. Aналогично чтобы подключить логику ReactContext нам нужно обернуть содержимое div className="wrapper" в компонент объекта context - Provider. Т.е. в <SearchContext.Provider>...</SearchContext.Provider> -->
<!-- И присвоим значение для нашего context - передадим туда объект с переменными из useState: {searchValue, setSearchValue} -->
<!-- 			<SearchContext.Provider value={{searchValue, setSearchValue}}> -->
<!--Т.к. мы теперь будем доставать searchValue, setSearchValue из context - больше не нужно из извлекать из пропсов. И не нужно дальше передавать их в Search.jsx и там тоже потом извлекать не нужно-->

<!-- Каждый объект Context используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения. -->
<!-- Также существует useContext. Он подобен addEventListner - отслеживает изменения контекста и все перерисовывает компоненты, которые хоть как-то используют этот контекст в случае его изменения. -->
<!-- const value = useContext(MyContext);  Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве. -->

<!-- Вытаскиваем то что нам нужно context в том месте где нам нужно получить доступ к содержимому context  -->
<!-- В нашем случае мы вытаскиваем весь объект, поэтому и указываем объект {} (можем вытаскивать и просто переменную, массив) внутри Search.jsx-->
<!-- 	const {}= React.useContext(SearchContext) -->
<!-- Получается, что хук useContext внутри Search.jsx ссылается на переменную SearchContext, которая является объектом контекста и определена в Аpp.jsx. А значению этой переменной с помощью компонента Provider в Аpp.jsx мы присвоили объект value={{searchValue, setSearchValue}} -->
<!-- И теперь мы можем вытащить наши переменные с помощью useContext, просто вписав их внуть только что созданной const в Search.jsx  -->
<!-- 	const {searchValue, setSearchValue}= React.useContext(SearchContext) -->
<!-- Теперь Search.jsx не может найти SearchContext. Нужно его туда экспортировать. Но нельзя писать export default дважды. Чтобы экспортировать отдельные куски кода, достаточно перед ключевым словом объявления сущности (const, let, function) приписать export  -->
<!-- В App.jsx дописываем export -->
<!-- export const SearchContext = React.createContext(); -->
<!-- Теперь в том месте, где нам нужно вытащить (нашем случае это Search.jsx) импортируем context-->
<!-- import { SearchContext } from '../../App'; -->
<!-- Обращаем внимание что мы вытаскиваем через деструктуризацию, иначе нам вернется jsx компонент, который через export default экспортирован (т.е. App.jsx в нашем случае) а не переменная значение SearchContext-->

<!-- Готово! Теперь у нас работает поиск с помощью ReactContext при этом мы избежали Props Drilling -->

<!-- Теперь разбираемся что мы сделали -->
<!-- По смыслу const SearchContext = React.createContext() это создание глобальной переменной -->
<!-- Дальше в этой строчке -->
<!-- 			 <SearchContext.Provider value={{searchValue, setSearchValue}}>...</SearchContext.Provider> -->
<!-- Мы говорим Provider оповести все компоненты, которые ты обернул, что переменной SearchContext мы присвоили значение value={{searchValue, setSearchValue}} -->
<!-- Теперь экспортируем SearchContext из App.jsx и импортируем в Search.jsx -->
<!-- И теперь мы можем извлечь записанные в переменную данные с помощью деструктурицазии и использования хука useContext в любом дочернем компоненте, компонента где мы мы context создавали  -->
<!-- const { searchValue, setSearchValue } = React.useContext(SearchContext); -->
<!-- Т.о useContext(SearchContext) вернет нам то, что хранится в value в SearchContext.Provider, а у нас там value={{searchValue, setSearchValue}}  -->

<!-- Теперь заюзаем context в Home.jsx вместо прокидывания переменных в пропсы -->

<!-- ======================================================================================================================== -->

<!-- Redux Toolkit-->
<!-- На сегодня это самая популярная и актуальная библиотека для создания глобального хранилища -->
<!-- Redux Toolkit можно использовать с любым фреймворком и с clearJS -->

<!-- Сделаем фильтрацию по категориям через Redux -->

<!-- Ставим редакс тулкит и перемычку между реактом и редаксом -->
<!-- npm i @reduxjs/toolkit react-redux-->

<!-- Начало практики Redux 53:10 -->

<!-- Создаем Redux хранилище -->
<!-- Создаем файл store.js и импортируем метод для создания хранилища из библиотеки, создаем хранилище и экспортируем его -->

<!-- configureStore - этот метод просто создает хранилище -->
<!--

import { configureStore } from '@reduxjs/toolkit'

export const store = configureStore({
  reducer: {},
})

 -->
 <!--В объект reducer мы будем записывать подразделения нашего хранилища -->

<!-- Импотрируем наше хранилище в index.js -->
<!-- import {store} from './redux/store'  -->

<!-- Чтобы Redux и наше хранилище store подружить с реактом мы используем библиотеку react-redux -->
<!-- Как и с контестом импортируем Provider из библиотеки react-redux ! Важно ! Не из '@reduxjs/toolkit'. Передаем провайдеру пропс store, который мы создали -> Записываем в атрибут(пропс) store Провайдера наше хранилище (которое существует в виде js объекта) и оборачиваем провайдером наше приложение. Можно с оборачивать вместе с роутером или без роутера. Теперь все наше приложение знает что в нем есть логика redux -->

<!-- Теперь наш root.render в index.js выглядит так

root.render(
	<Provider store={store}>
		<BrowserRouter>
			<React.StrictMode>
			<App />
			</React.StrictMode>
		</BrowserRouter>
	</Provider>,
);

 -->

 <!--На данном этапе: хранилище создано (пока оно пустое). React и Redux знают друг о друге. -->
 <!-- Теперь нужно создать слайс -->
 <!-- Slice - это такой кусочек от общего хранилища, в котором все живет своей жизнью. стор - это все хранилище целиком, состоящее из складов-слайсов. -->
 <!-- Для разных компонентов мы будем создавать свой слайс -->
 <!-- У нас будет 3 слайса:
 - pizzaSlice.js - логика для массива пицц
 - cartSlice.js - логика для корзины
 - filterSlice.js - логика для категорий и сортировки, ну и наверное поиска
  -->

<!-- Для начала, для примера сделаем счетчик -->

<!-- Создаем их в папке slices и копируем туда код из документации -->

<!-- Экспортируем экшены для изменения state, чтобы потом воспользоваться ими в нужном нам файле -->
<!-- export const { increment, decrement, incrementByAmount } = counterSlice.actions -->
<!-- Экспортируем из filterSlice.js в store.js функцию - counterReducer -->
<!-- В filterSlice.js пишем -->
<!-- export default counterSlice.reducer -->
<!-- В store.js пишем -->
<!-- import counterReducer from "./slices/filterSlice" -->
<!-- Теперь у нас есть доступ в store.js к counterReducer -->
<!-- Передаем ее в reducer в store.js -> Меняем значение reducer в store.js с пустого объекта на { counter: counterReducer }. В данном случае мы назвали наше состояние - counter и вся логика, которая будет менять это состояние находится в counterReducer -->

<!-- Slice создан и подключен. -->
<!-- Теперь мы можем использовать хуки React-Redux, чтобы позволить компонентам React взаимодействовать с хранилищем Redux. Мы можем считывать (извлекать/доставать) данные из хранилища с помощью useSelector и совершать действия с помощью useDispatch.  -->

<!-- Идем в файл, где хотим использовать хуки и импортируем их. Мы будем их использовать в Арр.jsx -->
<!-- import { useSelector, useDispatch } from 'react-redux' -->
<!-- В этот же файл импортируем экшены, которыми мы хотим воспользоваться из нашего слайса -->
<!-- import { decrement, increment } from './redux/slices/filterSlice' -->
<!-- Создаем переменные в нашем компоненте для использованию хуков -->
<!--
const count = useSelector((state) => state.counter.count);
const dispatch = useDispatch();
	-->
<!-- Теперь можно вставить кусок разметки ниже в наш компонент (у нас это Арр.jsx) и убедиться в работоспособности кода -->
<!--
 			<button
				aria-label="Increment value"
				onClick={() => dispatch(increment())}
			>
				Increment
			</button>
			<span>{count}</span>
			<button
				aria-label="Decrement value"
				onClick={() => dispatch(decrement())}
			>
				Decrement
			</button>
-->

<!-- Готово! -->

<!-- Теперь разбираемся как мы создали счетчик. 1:18:50 -->
<!-- Наше глобальное хранилище может содержать много разных редюсеров из разных слайсов -->
<!-- Когда мы создавали наш редюсер, то задали ему начальное состояние, (как для хука):

const initialState = {
  count: 0,
  count1: 0,
  count2: 0,
  count3: 0,
  count4: 0,
}

 -->
<!-- Свойств в initialState может быть сколько угодно -->
<!-- Далее мы создаем логику, которая будет обрабатывать наш state -->
<!-- Для этого мы используем метод createSliсe из reduxToolkit -->
<!-- Весь слайс мы записываем в переменную counterSlice и экспортируем ее для получения доступа к ней в других файлах -->
<!-- В сам метод createSliсe мы передаем объект в котором указываем настройки нашего слайса: название, начальное состояние и в свойстве reducers методы, которые будут менять наш State (экшены)-->
<!-- incrementByAmount - позволяет вручную поменять значение счетчика, вписав туда свое значение -->

<!-- Потом мы вытаскиваем из объекта counterSlice.actions все экшены (методы) и экспортируем их -->
<!-- В counterSlice.actions - содержится объект описанный в свойстве reducers настроек нашего слайса -->

<!-- Функция counterSlice.reducer обрабатывает слайс и его методы , которые указаны в настройках слайса в reducers, так, чтобы могли просто воспользоваться слайсом и его  методами в нужных нам файлах, если мы импортировали эти методы в нужные файлы -->

<!-- Т.о мы экспортируем:
1. сам слайс -  counterSlice.- export const counterSlice = createSlice({...})
2. все его методы для изменения state из counterSlice.actions.- export const { increment, decrement, incrementByAmount } = counterSlice.actions
3. и версию слайса, подготовленную для записи в глобальное хранилище store.- export default counterSlice.reducer
 -->

 <!-- Чтобы добавить новый метод, для изменения state, нужно прописать его в свойстве reducers настроек нашего слайса -->

 <!-- Далее мы в хранилище (store.js) импортируем на слайс -->
 <!-- import counterReducer from './slices/filterSlice'; -->
 <!-- И говорим: store, у тебя будет редюсер, который будет называться counter и ему мы присвоим логику из counterReducer, который мы импортировали из  -->
 <!-- './slices/filterSlice'; -->
 <!-- Можно редюсер назвать также как и значение - counterReducer, тогда можно использовать сокращенную запись объета -->

 <!-- Далее мы пошли в Аpp.jsx и импортировали туда хуки - useSelector, useDispatch и наши методы для изменения state - increment, decrement, incrementByAmount -->
 <!-- Теперь вешаем на нужный объект обработчик. Например: -->
 <!-- 				onClick={() => dispatch(increment())} -->
 <!-- Просто прописать onClick={() => increment()}  - нельзя , работать не будет. Потому что increment() - вернет нам объект со свойствами payload и type, который передав в dispatch() выполнит заданное в increment() действие. Функция, записанная в dispatch сама сделает все что нужно.  -->
<!-- ============================================================================================================= -->
<!-- Axios -->
<!-- Подробнее -->
<!-- https://axios-http.com/ -->
<!-- Устанавливаем Axios -->
<!-- npm i axios -->
<!-- импортируем в файл, где хотим воспользоваться, в нашем случае Home.jsx -->
<!-- import axios from 'axios'; -->
<!-- У axios много методов, мы сейчас посылаем запрос для получение данных от сервера, для этого существует метод get -->
<!-- 			// При использовании axios в response будут данные уже в js формате, а не в json, как при fetch, но они будут в виде объекта. Сама же основа будет храниться в свойстве data, обращаясь к нему мы пожемо пользоваться данными -->
<!-- ========================================================================================================================= -->

<!-- хук useRef -->
<!-- Нужен для взаимодействия с дом-элементами -->
<!-- Делаем чтобы при очистке инпута поиска, на нем оставался фокус -->
<!-- 1 Создаем переменную, которая будет хранить ссылку на дом-элемент инпута -->
<!-- const inputRef=React.useRef() -->
<!-- 2 Теперь в нужном элементе в атрибуте ref указываю внутри {} в качестве ссылки нашу переменную -->
<!--
<input
ref={inputRef}
/>
-->
<!-- Ссылка сохранена -->

<!-- 3 Сделаем ф-цию, которая будет одноверменно очищать и оставлять фокус на инпуте
	const clearInput = () => {
		setSearchValue('');
		inputRef.current.focus();
	};
	-->
 <!-- Вешаем ее на нашу иконку  -->
 <!--     <img
					onClick={clearInput}
					className={styles.close}
					src={close}
					alt="closeIcon"
			  	/> -->
<!-- ================================================================================================================ -->
<!-- Debounce -->

<!-- Чтобы запрос на бэк делался не моментально по изменению инпута, а через промежуток небольшой (когда мы все допишем) используем Debounce -->
<!-- Функция debounce Lodash возвращает функцию debounce, которая при вызове будет выполнять функцию через X миллисекунд, прошедших с момента ее последнего выполнения. -->
<!-- Другими словами, когда мы вызываем debounce, это гарантирует, что все остальные вызовы будут игнорироваться в течение ms. -->
<!-- Устанавливаем Debounce -->
<!-- npm i lodash.debounce -->
<!-- lodash - это большая библиотека разных готовых функций для js -->
<!-- Вся она нам не нужна, а только debounce в ней -->
<!-- Синтаксис такой же как у setTimeout, но в первый аргумент можно передавать только функцию, react сам не будет из других форматов функцию делать -->

<!-- 	const testDebounce = debounce(() => {
		console.log('Сделал паузу и написал это');
	},2000);
	 -->
<!-- Если ф-ция debounce (код выше) находится внутри компонента Search, то каждое изменение инпута (=> изменение state) приводит к перерисовке компонента Search => ф-ция debounce будет пересоздаваться и перезапускаться после каждого перерендера через указанное время. Чтобы решить эту проблему и функцию запускалась, только 1 раз, когда мы весь запрос дописали, используется хук useCallback -->
<!-- Синтаксис у useCallback похож на useEffect, отличия в работе: useCallback - создаст,вернет функцию и запишет ее в переменную, useEffect - не вернет ф-цию, но вызовет ее -->
<!-- useCallback возвращает один и тот же экземпляр передаваемой функции (параметр 1) вместо создания нового при каждом повторном рендеринге компонента. Новый экземпляр передаваемой функции (параметр 1) может быть создан только при изменении массива зависимостей (параметр 2). -->
<!-- Оборачиваем хуком нашу функцию. (не забывам у зависимостях узазать пустой массив [](т.к. мы не собираемся ее пересоздавать)) И теперь у нас в testDebounce записана та же функцию, что и раньше, но благодаря хуку useCallback этот конкретный экземпляр не будет пересоздаваться и его теперь можно использовать внутри изменяющегося компонента Search-->

<!--
	const testDebounce = React.useCallback(
		debounce(() => {
			console.log('Сделал паузу и написал это');
		}, 2000),
		[],
	);
-->

<!-- Применим useCallback и debounce к нашей функции, вызываемой при изменении инпута -->
<!--
    const onChangeInput = React.useCallback(
		debounce((event) => {
			setSearchValue(event.target.value);
		}, 2000),
		[],
	);
	 -->

<!-- При попытке писать тепрь не появляется в инпуте ничего -->
<!-- Получилось следующее: у нас принудительно value у инпута задано value={searchValue}, а оно у нас == '' по умолчанию. event-это событие и оно не вызывается сразу, в момент изменения инпута. И у нас висит задержка на event в 2000ms через debounce. Новое значение searchValue должно присвоиться через ms, причем получить его должно из инпута, но т.к. через ms в инпуте по прежнему '', то новое значение searchValue остается ''. Замкнутый круг. -->
<!-- Чтобы это исправить теперь нам нужно создать дополнительно локальный state, чтобы иметь возможность писать в инпут, чтобы потом взять из него данные и на их основе изменить searchValue через время, указанное в debounce-->
<!-- Пишем внутри Search -->
<!-- 	const [value,setValue]=React.useState('') -->

<!-- меняем в инпуте и в иконке крестика searchValue на value -->

<!-- Изменим и переименуем функцию с debounce на updateSearchValue -->
<!-- сделаем, чтобы вызывался updateSearchValue при изменении value -->

<!--
     const updateSearchValue = React.useCallback(
	 	debounce((value) => {
	 		setSearchValue(value);
	 	}, 2000),
	 	[],
	 ); -->

<!-- Функцию onChangeInput меняем -->

<!--
const onChangeInput = (event) => {
		// Вот это действие выполняется сразу: value - присваивается значение event.target.value (т.е. то что мы ввели в инпут)
setValue(event.target.value);
		// А это только через 2000мс. Т.к. в функции updateSearchValue записана функция оберннутая в debounce с таймером 2000мс
updateSearchValue(event.target.value);
	};
	-->
<!-- Теперь можно писать в инпут и setSearchValue будет отрабатывать как положено; -->
<!-- Обновим функцию для очистки поля инпута -->
<!--
	const clearInput = () => {
		setSearchValue('');
		setValue('');
		inputRef.current.focus();
	};
 -->
<!-- Получилось так: мы моментально меняем значение инпута, получаем это значение, а потом мы создали новую ф-цию, которая будет менять searchValue, но с задержкой (updateSearchValue()), ссылку на эту функцию мы сохраняем с помощью useCallback, чтобы она не пересоздавалась и не перезапускалась, а запускалась лишь при первом рендере -->
<!-- !Извлекать searchValue из  React.useContext(SearchContext) нам больше не нужно -->
<!-- Дальше при запуске updateSearchValue() происоходим изменение searchValue, новое значение попадает в context, а оттуда его берет Home.jsx и там уже попадает в useEffect и меняется запрос на сервер-->
<!-- ================================================================================================================ -->
<!-- Делаем пагинацию на Redux -->
<!-- Работаем в filterSlice.jsx -->
<!-- Добавляем в initialState  -->
<!-- currentPage:1 -->
<!-- Добавляем в reducers метод для изменения currentPage -->
<!--
		setCurrentPage(state, action) {
			state.currentPage = action.payload;
		},
 -->

 <!-- И добавляем его в перечень экспортируемых -->
 <!-- export const { setActiveCategory, setActiveSortType, setCurrentPage } = filterSlice.actions; -->

<!-- Импортируем хук из 'react-redux' в Pagination.jsx-->
<!-- import { useSelector } from 'react-redux'; -->
 <!-- Добавляем к импортируемым из filterSlice методам метод setCurrentPage в Home.jsx-->
<!-- import { setActiveCategory, setCurrentPage } from '../redux/slices/filterSlice'; -->

<!-- Старый стейт нам не нужен=> удаляем: -->
<!-- const [currentPage, setCurrentPage] = React.useState(1); -->

<!-- Добавляем currentPage к перечню переменных, доставаемых из слайса через useSelector -->
<!-- 	const { sortType, activeCategory, currentPage } = useSelector((state) => state.filter); -->

<!-- dispatch мы уже достали заранее -->
<!-- 	const dispatch = useDispatch(); -->

<!-- Создаем новую функцию, которая будет менять стейт текущей страницы по событию -->
<!--
	const onChangePage = (value) => {
		dispatch(setCurrentPage(value));
	};
 -->
 <!-- В атрибутах компонента Pagination в Home.jsx прописываем новую функцию на выполнение по событию   -->
 <!-- onChangePage={onChangePage} -->
 <!-- И убирам оттуда и из пропсов в PaginationBlock в Pagination.jsx currentPage-->
 <!-- currentPage={currentPage} -->

<!-- Достаем currentPage из store в Pagination.jsx-->
 <!-- 	const { currentPage } = useSelector((state) => state.filter); -->

 <!-- В принципе нет разницы: передать в проспсы в Home.jsx в компонент Pagination currentPage={currentPage} или достать currentPage из store в Pagination.jsx -->

 <!-- В атрибутах в PaginationBlock в Pagination.jsx уже прописано -->
 <!-- 
page={currentPage}
onChange={handleChange} 
-->
<!-- И handleChange уже написана -->
<!--
	const handleChange = (event, value) => {
		onChangePage(value);
	};
 -->

<!-- Готово! -->
<!-- ========================================================================================================================================== -->

<!-- ========================================================================================================================================== -->
<!-- #16 -->
<!-- Реализуем закрытие попапа по клику на любое место вне его -->
<!-- Получаем ссылку на элемент, за которым хотим следить -->
<!-- Создаем переменную sortRef для записи ссылки на элемент и вешаем на этот элемент атрибут ref с этой переменной в значении ref={sortRef} -->
<!--

	    const sortRef = useRef();

      <div
			className="sort"
			ref={sortRef}
			>
			</div>
 -->
 <!-- Теперь, когда попап активен в нашей ссылке на элемент будет элемент с классом sort, у которого дочерние элементы sort__label и sort__popup -->
 <!-- Теперь внутри компонента Sort делаем обработчик клика на весь body. Пишем его внутри useEffect, иначе ссылка не него будет теряться и мы не сможем удалять именно его впоследствии. -->

 <!-- 	const sortRef = useRef();
	// console.log(sortRef.current);

	const popupCloser = (event) => {
		// JavaScript метод composedPath() объекта Event возвращает путь события, представляющий собой массив объектов, на которых будут вызваны обработчики событий.
		if (!event.composedPath().includes(sortRef.current)) {
			setIsShow(false);

		}
	};
	// Получается так: в sortRef.current хранится наш компонент с классом sort. event.composedPath() - возвращает массив элементов на которых слышно событие. И теперь по клику в любом месте идет проверка - содержит ли массив из event.composedPath() элемент с классом sort. Если не содержит - то ставим флаг isShow=false.

	// Оборачиваем обработчик событий в useEffect без зависимостей, чтобы он навешивался только при первом рендере, и не пересоздавался и не навешивал новые.
	React.useEffect(() => {
		// Мы можем вешать обработчики через addEventListener на "главных родителей", к которым по другому нельзя обратиться из компонента
		window.document.body.addEventListener('click', popupCloser);
	}, []);
	 -->

 <!-- Сейчас, если уйти со страницы, а потом вернуться - навесится новый обработчик на body, но старый сам не удаляется, (потому что технически мы на одной странице находимся) нужно его удалять вручную -->
 <!-- Для этого добавим в useEffect строчки -->
 <!-- 
 		return () => {
			window.document.body.removeEventListener('click', popupCloser);
		};
  -->
<!-- Эта стрелочная функция внутри return будет вызываться перед размонтированием элемента (Согласно документации useEffect). Она и будет удалять наш обработчик при "переходе" на другие страницы -->

<!-- ========================================================================================================================================== -->
<!-- Делаем редакс логику для корзины -->
<!-- По хорошему нужно сделать так: добавлять в массив все пиццы, а потом в Cart.jsx делать группировку по характеристикам (опциям) и по id -->
<!-- Сделаем для начала простой функционал -->
<!-- Сделаем группировку только по id -->
<!-- Создаем новый слайс cartSlice.js -->

<!--
import { createSlice } from '@reduxjs/toolkit';
const initialState = {
	items: [],
	totalPrice: 0,
};
export const cartSlice = createSlice({
	name: 'cart',
	initialState,
	reducers: {
		// Добавление в корзину в главном меню
		addItem(state, action) {
			state.items.push(action.payload);
		},
		// Удаление всех товаров данного типа из корзины(Крестик напротив элемента в корзине)
		removeItem(state, action) {
			state.items = state.items.filter((obj) => obj.id !== action.payload);
		},
		// Полная очистка корзины
		clearItems(state) {
			state.items = [];
		},
		// Общая стоимость товаров в корзине
		setTotalPrice(state, action) {
			state.totalPrice = action.payload;
		},
	},
});

export const { addItem, removeItem, clearItems, setTotalPrice } = cartSlice.actions;

export default cartSlice.reducer;
 -->
 <!-- Добавляем в store новый слайс cartSlice -->

 <!-- 
import cartReducer from './slices/cartSlice';
export const store = configureStore({
 	reducer: {
		filter: filterReducer,
		cart: cartReducer,
	},})
  -->

<!-- Переходим в Header.jsx -->
<!-- Имптортируем хук -->
<!-- import { useSelector} from 'react-redux'; -->
<!-- Вытаскиваем states -->

<!-- 	const { totalPrice, items } = useSelector((state) => state.cart); -->

<!-- Вставляем значения стейтов в поля компонента -->

<!-- Элемент с общей ценой товаров в корзине -->
<!-- <span>{totalPrice} ₽</span> -->

<!-- Элемент с количеством товаров в корзине -->
<!-- <span>{items.length}</span> -->

<!-- Делаем добавление товара в корзину. Переходим в pizzaBlock -->
<!-- Импортируем хуки -->
<!-- import { useDispatch, useSelector } from 'react-redux'; -->
<!-- Создаем функцию onClickAddItem, которая будет срабатывать по нажатию на кнопку "добавить в корзину" -->
<!-- Внутри неё Генерируем объект item, который будем отправлять в корзину -->

<!--
	const onClickAddItem = () => {
		const item = {
			id,
			title,
			price,
			imageUrl,
			size: activeSize,
			type: activeType,
		};
	};
 -->

<!-- Достаем dispatch -->
<!-- 	const dispatch = useDispatch(); -->

<!-- Импортируем метод из reducers из cartSlice -->
<!-- import {addItem} from "../../redux/slices/cartSlice" -->

<!-- Добаляем dispatch к нашей функции -->
<!--
	const onClickAddItem = () => {
		const item = {
			id,
			title,
			price,
			imageUrl,
			size: activeSize,
			type: typeNames[activeType],
		};
		dispatch(addItem(item))
	};
 -->

 <!-- Вешаем функцию onClickAddItem на нужную нам кнопку -->
 <!-- onClick={onClickAddItem} -->

 <!-- Теперь в редакс передаются все нужные нам данные для отображения товаров в корзине и работает счетчик кол-ва товаров в Header.jsx -->

<!-- Вычисляем totalPrice -->
<!-- Идем в cartSlice -->
<!-- Изменяем метод addItem -->
<!--
		addItem(state, action) {
			state.items.push(action.payload);
			// При добавлении товара сразу вычисляем общую стоимость товаров в корзине, используем для этого метод reduce
			state.totalPrice = state.items.reduce((sum, obj) => {
				return obj.price + sum;
			}, 0);
		},
 -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- reduce - метод переборки массивов, часто используется для перебора с накоплением суммы -->
<!-- В reduce передаем:
1. коллбэк функцию, которая будет вычислять значение ((prev,item,index)=>{return prev+item;})
2. изначальное состояние вычисляемого значения (по умолчанию - значение элемента с индексом 0), но можно задать принудительно. Причем допустим любой тип данных. у нас так и есть. Оно = (0)

В свою очередь функция, которая будет вычислять значение принимает в себя параметры:
1. Вычисляемое значение (prev)
2. текущий элемент массива (item)
3. индекс текущего элемента массива (index)
 -->

<!-- Не забываем сделать return, все что вернет функция запишется в prev  -->

<!--
let a = [1,2,3,4]
let b = a.reduce((prev,item,index)=>{
	return prev+item;
},0);

console.log(b) //10
 -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- find - метод переборки массивов, передаем в него стрелочную функцию, которая принимает (item, index, array), если эта функция вернет true, то будет возвращен текущий элемент, если false- то find вернет undefined-->
<!-- findIndex - все то же самое, только возвращает индекс текущего элемента, только если false- то findIndex вернет -1 -->
<!-- lastIndexOf - метод переборки массивов, возвращает индекс последнего вхождения искомого элемента в строковый объект (строку). Принимает искомую строку. Если ничего не находит возвращает -1 -->
<!--
const d = "hello";
const f = d.lastIndexOf("l") //3
 -->

<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- Продолжаем -->
<!-- Сделаем чтобы добавлялся в корзину всегда только один уникальный объект товар (пицца), а дополнительные - увеличивали его количество -->
<!-- Изменяем наш addItem -->
<!--
		addItem(state, action) {
			// Ищем элемент в массиве, и если находим добавляем ему к счетчику +1, иначе добавляем его в корзину и устанавливаем счетчик = 1

			const findItem = state.items.find((obj) => obj.id === action.payload.id);

			if (findItem) {
				findItem.count++;
			} else {
				// Не просто пушим объект из action.payload, а Берем все что нам пришло с компонента и в конец добавляем count:1 и пушим уже дополненный объект
				// ...action.payload - содержит весь объект, который мы добавляем (item) , но в деструктурированном виде, и мы просто дописываем ему еще одну пару ключ:значение - count: 1 и потом пушим это всё.
				state.items.push({...action.payload, count: 1 });
			}
			state.totalPrice = state.items.reduce((sum, obj) => {
				// Не забываем что теперь для подсчета общей суммы, с учетом счетчика нужно перемножать цену на количество
				return sum + obj.price*obj.count;
			}, 0);
		},
 -->

<!-- У нас пока в хедере некорректно количество товара отображается -->

<!-- 38:30 -->

<!-- Делаем отображение счетчика на кнопке добавить -->

<!-- Находим в стейте объект (элемент массива items) которому хотим увеличить счетчик  -->
<!-- 	const cartItem = useSelector((state) => state.cart.items.find((obj) => obj.id === id)); -->
<!-- Делаем проверку, чтобы не крашилось приложение -->
<!-- 	const addedCount = cartItem ? cartItem.count : 0 -->
<!-- Вставляем значение счетчика в разметку и делаем условыный рендер -->
<!--
						<span>Добавить</span>
					  {addedCount > 0 && <i>{addedCount}</i>}
 -->
<!-- 45:20  -->
<!-- Переходим в cart.jsx -->
<!-- Импортируем хуки, достаем dispatch и массив всех пицц, добавленных в корзину  -->
<!--
import { useDispatch, useSelector } from 'react-redux';
	const cartItems = useSelector((state) => state.cart.items);
	const dispatch = useDispatch();
 -->
 <!-- Создаем новый компонент cartItem.jsx  -->
 <!-- Вставляем туда разметку -->

<!-- Преобразуем массив объектов пицц из redux в массив наших новых компонентов, и отрендерим их в Cart.jsx. В качестве ключа зададим id и передадим в пропсы в CartItem каждый объект item. В CartItem.jsx мы из вытащим   -->
 <!-- 
 					{cartItems.map((item) => (
						<CartItem key={item.id} {...item} />
					))}
   -->
<!-- В CartItem.jsx мы вытаскиваем из пропсов все нужные свойства, через деструктуризацию (с использованием {})-->
<!-- const CartItem = ({id, title, price, imageUrl, size, type, count}) => {} -->
<!-- И вписываем значения вытащенных свойств в разметку -->
<!-- 						src={imageUrl} -->
<!-- 					<h3>{title}</h3> -->
<!--
					<p>
						{type}, {size} см.
					</p>
 -->
 <!-- 					<b>{count}</b> -->
 <!-- 					<b>{price * count} ₽</b> -->

 <!-- 49:00 -->

 <!-- Чиним счетчик в Header.jsx -->
 <!-- В const Header добавляем переменную в неё запишем сумму всех счетчиков, добавленных в корзину пицц  -->
 <!-- 
 	const totalCount = items.reduce((sum, item) => {
		return sum + item.count;
  -->
<!-- Заменим переменную в разметке на новую  -->
<!-- <span>{totalCount}</span> -->

<!-- 55:35-59:00 -->

<!-- Делаем добавление/убавление количества товара в коризине по клику на кнопки + и - -->

<!-- Создаем функции, которые будут диспатчить по клику в redux -->

<!--
	const onClickPlus = () => {
		dispatch(addItem({ id }));
	};
	const onClickMinus = () => {
		dispatch(minusItem( id ));
	};
 -->

 <!-- Создаем функцию minusItem в reducers в redux и воспользуемся уже готовой addItem -->
 <!-- 
 		minusItem(state, action) {
			const findItem = state.items.find((obj) => obj.id === action.payload);
			if (findItem) {
				findItem.count--;
			}
		},
  -->

<!-- В action.payload хранится то, что мы передаем в нее, когда диспатчим. Если dispatch(minusItem( id )) , то там будет число (например 8), если dispatch(addItem({ id })), то там будет часть объекта, который мы деструктурировали в пропсах (ключ-значение) ({id:8}), Это нужно учитывать когда мы из action.payload достаем данные в слайсе. -->

<!-- Кнопки работают, но в хедере сумма не уменьшается -->

<!-- 59:00 -->
<!-- Делаем удаление товара из корзины -->
<!-- Делаем функцию по клику на кнопку Х (удаление товара) в CartItem.jsx -->
<!--
	const onClickRemove = () => {
		// Метод window.confirm выводим alarm попап с вопросом, указанном в параметрах, при клике на OK возвращает true
		if (window.confirm('Вы действительно хотите удалить этот товар?')) {
			dispatch(removeItem(id));
		}
	};
 -->

<!-- Добавляем новый метод в reducerc -->

 <!-- 
 		removeItem(state, action) {
			//Метод filter переберет массив, и вернет новый в который войдут элементы, для которых вызов колбэк функции вернул true
			state.items = state.items.filter((obj) => obj.id !== action.payload);
		},
  -->

<!-- И добавляем его к импортируемым методам -->

<!-- export const { addItem, minusItem, removeItem, clearItems } = cartSlice.actions; -->

<!-- import { addItem, minusItem, removeItem } from '../redux/slices/cartSlice'; -->

<!-- Товары удаляются, но хедер по прежнему не реагирует -->

<!-- 1:00:00 -->

<!-- Делаем очистку корзины -->

<!-- Идем в Cart.jsx -->
<!-- Добавляем новую функцию, и вешаем ее на онклик на кнопкн очистить корзину -->

<!--
	const onClickClearItem = () => {
		if (window.confirm('Вы действительно хотите очистить корзину?')) {
			dispatch(clearItems());
		}
	};
 -->

 <!-- В reducers добавляем метод  -->

 <!-- 
		clearItems(state) {
			state.items = [];
			// Не забываем очистить общую сумму при очистке корзины
			state.totalPrice = 0;
		},
  -->

<!-- Не забываем экспортировать и импортировать новый метод -->

<!-- Делаем отображение суммы и кол-ва товаров в Cart.jsx-->

<!-- Достаем state -->
<!-- 	const { totalPrice, items } = useSelector((state) => state.cart); -->

<!-- Копируем код для кол-ва товаров из Header.jsx -->
<!--
	const totalCount = items.reduce((sum, item) => {
		return sum + item.count;
	}, 0);
 -->

 <!-- Вписываем в разметку данные -->
 <!-- 							Сумма заказа: <b>{totalPrice} ₽</b> -->
 <!-- 							Всего пицц: <b>{totalCount} шт.</b> -->

 <!-- Делаем рендер компонента пустой корзины, когда там нет товаров -->

 <!-- Создаем компонент пустой корзины EmptyCart.jsx -->
 <!-- Вставляем разметку -->

 <!-- Корректируем его для jsx формата:
 меняем a href на Link to (из react-router-dom (не забываем Link импортировать)),
 картинку подключаем по новому пути
   -->

<!-- Делаем в Cart.jsx условный рендер пустой корзины, перед основным рендером, при условии что массив пицц пустой, т.е. если мы ничего не добавили или все удалили  -->

 <!-- 
 	if (items.length === 0) {
		return <EmptyCart />;
	}
  -->

<!-- Включаем в Header.jsx слежение за изменением totalPrice, и перерисовку, в случае его изменения -->

<!--
	useEffect(() => {}, [totalPrice]);
 -->

 <!-- Делаем корректное отображение опций пиццы в корзине -->

 <!-- В PizzaBlock в onClickAddItem присваиваем size -->

 <!-- 			size: sizes[activeSize], -->

<!-- В CartItem.jsx -->
<!--
				<p>
					{type}, {size} см.
				</p>
 -->

 <!-- Остались баги: totalPrice не реагирует на уменьшение кол-ва конкретной пиццы (при клике на -) и также кол-во пицц, при клике на - можно загнать меньше 0 -->

<!-- ========================================================================================================================================== -->
<!-- Используем синтаксис async/await, чтобы сократить код в запросе с бэка -->

<!-- 	// Добавляем к стрелочной функции внутри useEffect ключевое слово async, чтобы иметь возможность пользоваться await -->

<!-- Благодаря await запрос через axios или fetch превратиться из асинхронного в синхронный, ответ из промиса автоматически будет извлечен и ответ на этот запрос будет дожидаться весь следующий код. Не используя при этом промисы -->

<!-- Промисы наоборот превращают синхронный код в асинхронный -->

<!--
	const fetchPizzas = async () => {
		setIsLoading(true);
		const res = await axios.get(
			`https://64845cf9ee799e3216269459.mockapi.io/items?${
				activeCategory > 0 ? `category=${activeCategory}` : ''
			}&sortBy=${sortType.sortProperty.replace('-', '')}&order=${
				sortType.sortProperty.includes('-') ? 'asc' : 'desc'
			}&filter=${searchValue ? searchValue : ''}&page=${currentPage}&limit=4`,
		);
		// Больше не надо использовать then. Ответ от сервера уже распакован и мы просто записали его в переменную res
		setItems(res.data);
		setIsLoading(false);
		// Чтобы при рендере автоматически страница вверх прокрутилась
		window.scrollTo(0, 0);
	};
 -->

<!-- Не забываем запустить вынесенную функцию -->
 <!-- 
 		fetchPizzas();
  -->

<!-- Ошибки нужно ловить, чтобы отобразить пользователью удобноваримый контент, а не оставлять один на один с консолью -->

<!-- Чтобы ловить ошибки, используя промисы, применяем метод catch -->

<!-- Чтобы ловить ошибки, используя async/await, применяем синтаксим try/catch. В блоке try пишем, что делать в случае успеха, catch - в случае ошибки. -->
<!-- Еще есть блок finally -->
<!-- Этот блок выполняется при любом исходе работы try/catch -->

<!--
finally{
				setIsLoading(false);
			}
 -->

<!--
try {
				const res = await axios.get(
					`https://64845cf9ee799e3216269459.mockapi.io/items?${
						activeCategory > 0 ? `category=${activeCategory}` : ''
					}&sortBy=${sortType.sortProperty.replace('-', '')}&order=${
						sortType.sortProperty.includes('-') ? 'asc' : 'desc'
					}&filter=${searchValue ? searchValue : ''}&page=${currentPage}&limit=4`,
				);
				setItems(res.data);

				window.scrollTo(0, 0);
			} catch (error) {

				console.log('ERROR:', error);
			}finally{
				setIsLoading(false);
			}
 -->

<!-- ========================================================================================================================================== -->
<!-- Выносим бизнес логику -->
<!-- Бизнес логика - абстактное понятие, включающее в себя запросы на бэк, их сохранение, обработку и использование -->
<!-- Чтобы бизнес логику вынести в redux создают и используют асинхронные экшены (createAsyncThunk)-->

<!-- Создаем новый слайс pizzasSlice -->

<!--
import { createSlice } from '@reduxjs/toolkit';
const initialState = {
	items: [],
};
export const pizzasSlice = createSlice({
	name: 'pizzas',
	initialState,
	reducers: {
		// Добавление в корзину в главном меню
		setItems(state, action) {
			state.items = action.payload.items;
		},
	},
});

export const { setItems } = pizzasSlice.actions;

export default pizzasSlice.reducer;
 -->

<!-- Добавляем его в store -->

<!-- Переделываем логику с запросом пицц -->
<!-- Идем в Home.jsx и достаем пиццы state из pizzasSlice. Старый локальный useState при этом убираем (	// const [items, setItems] = React.useState([]);) -->

<!--
	const { items } = useSelector((state) => {
		state.pizzas.items;
	});
 -->

<!-- ========================================================================================================================================== -->
<!-- Переделываем запрос и сохранение пицц с созданием и использованием функционала асинхронного экшена -->
<!-- У нас будет теперь одна функция, которая будет отвечать одновременно за: загрузку данных, показ статуса загрузки, сохранение данных -->

<!-- Создаем асинхронный экшн -->
<!-- метод createAsyncThunk создаент асинхронный экшн, принимает 3 параметра:
1-тип экшена в виде строки (у нас это pizzas/fetchPizzasFromReduxStatus) (Тут можно писать, что угодно, но для удобства и читабельности принято так: сначала указываем name нашего слайса/потом название функции, которая вызывает асинхронный экшн)

Строка, которая будет использоваться для создания дополнительных констант типа действия Redux, представляющих жизненный цикл асинхронного запроса:

Например, type аргумент 'users/requestStatus'будет генерировать следующие типы действий:

pending:'users/requestStatus/pending'
fulfilled:'users/requestStatus/fulfilled'
rejected:'users/requestStatus/rejected'

 (это нужно только для правильной идентификации экшена внутри редакса ),
 2 - функция, выполняющая экнш,
 3 - опции , -->
<!--
export const fetchPizzasFromRedux = createAsyncThunk(
	'pizzas/fetchPizzasFromReduxStatus',
	async (params) => {
		const { category, sort, order, filter, currentPage } = params;
		const { data } = await axios.get(
			`https://64845cf9ee799e3216269459.mockapi.io/items?${category}&sortBy=${sort}&order=${order}&filter=${filter}&page=${currentPage}&limit=4`,
		);
		return data;
	},
);
 -->

 <!-- Теперь список импортов слайса выглядит так -->
 <!-- 
 import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
 import axios from 'axios';
  -->

<!-- В Home.jsx импортируем наш асинхронный экшн, причем setItems больше не нужен в Home.jsx -->
<!-- import { fetchPizzasFromRedux } from '../redux/slices/pizzasSlice'; -->

<!-- В Home.jsx в fetchPizzas в блоке try диспатчим теперь так: -->
<!--
			dispatch(
				fetchPizzasFromRedux({
					category,
					sort,
					order,
					filter,
					currentPage,
				}),
			);
 -->

 <!-- В реакте принято, что если функция имеет приставку fetch - то она получает и сохраняет данные -->

<!-- в initialState добавим новое свойство status: '' -->

 <!-- Далее нужно в createSlice добавить extraReducers, и согласно синтаксису из документации задать действия для каждого из событий pending, fulfilled, rejected. Для этого обращаемся к builder и вызываем у него метод addCase и в его параметры передаем ((название функции, вызывающей асинхронный экшн).(одно из событий(pending, fulfilled, rejected)), функцию, которая будет отрабатывать на это событие)-->

<!-- createAsyncThunk вернет 3 статуса #.pending, #.fulfilled, #.rejected -->
<!-- Будем очищать массив пицц перед загрузкой и в случае ошибки -->
 <!-- 
 	extraReducers: (builder) => {
		builder
			.addCase(fetchPizzasFromRedux.pending, (state) => {
				state.status = 'Загружаю эту хуйню';
				state.items = [];
			})
			.addCase(fetchPizzasFromRedux.fulfilled, (state, action) => {
				state.items = action.payload;
				state.status = 'Наконец-то эта хуйня заработала';
			})
			.addCase(fetchPizzasFromRedux.rejected, (state) => {
				state.status = 'Хуйня не пашет';
				state.items = [];
			});
	},
  -->

<!-- Полная логика такая: -->
<!-- Создали функцию fetchPizzasFromRedux, ей говорим создай асинхроный экшн, выполни его и верни результат запроса. Потом в extraReducers мы эту функцию берем и проверяем статус выполнения и в соответствии с этим статусом говорим выполнить то или иное действие -->
<!-- В случае успешного получение ответа на запрос - мы результат записываем в state.items (state.items = action.payload), пока загрузка и если ошибка - очищаем массив пицц (state.items = []) -->

<!-- Мы теперь можем использовать функцию fetchPizzasFromRedux для разных слайсов, разных файлов и т.д. мы вынесли получение и сохранение пицц отдельным "модулем" -->

<!-- // Удаляем state isLoading из Home.jsx -->
<!-- Меняем все что в try/catch на   -->
<!--
		dispatch(
			fetchPizzasFromRedux({
				category,
				sort,
				order,
				filter,
				currentPage,
			}),
 -->
 <!-- try/catch нам больше не нужен, т.к. мы теперь отлов проводим в extraReducers -->

 <!-- Вытаскиваем через useSelector теперь еще и status -->

 <!-- 	const { items, status } = useSelector((state) => state.pizzas); -->
 <!-- И в разметке меняем условие отображения пустой корзины (условно ошибка получения пицц), скелетона или пицц в зависимости от полученного статуса -->

<!-- 				{status === 'error' ? (
					<EmptyCart />
				) : (
					<>
						<h2 className="content__title">Все пиццы</h2>
						<Pagination onChangePage={onChangePage} />
						<div className="content__items">{status === 'success' ? pizzas : skeleton}</div>
					</>
				)}
				 -->
<!-- Если мы хотим сделать запрос на бэк и сохранить результат в редаксе и что-то в редаксе поменять то это принято делать с помощью createAsyncThunk -->

<!-- ========================================================================================================================================== -->
<!-- ThunkAPI -->
<!-- ThunkAPI это второй аргумент, который принимает колбэк функция payloadCreator -->
<!--
thunkAPI: объект, содержащий все параметры, которые обычно передаются функции преобразователя Redux, а также дополнительные параметры:

  -->
<!-- Для нашего примера это будет выглядеть так -->
<!--
export const fetchPizzasFromRedux = createAsyncThunk(
	'pizzas/fetchPizzasFromReduxStatus',
	async (params, thunkAPI) => {
		const { category, sort, order, filter, currentPage } = params;
		const { data } = await axios.get(
			`https://64845cf9ee799e3216269459.mockapi.io/items?${category}&sortBy=${sort}&order=${order}&filter=${filter}&page=${currentPage}&limit=4`,
		);
		thunkAPI.rejectedWithValue()
		console.log(thunkAPI);
		console.log(thunkAPI.requestId)
		console.log(thunkAPI.getState().filter.currentPage);
		return data;
	},
);
 -->

<!--
Благодаря thunkAPI мы можем использовать все его нужные иногда методы, например:
диспатчить так же и в внутри createAsyncThunk, (dispatch),
вытащить state перед внесением в него изменений (getState),
с помощью signal (используя функционал AbortController.signal) можем прерывать наш запрос (если она например слишком долго отправляется) для этого его используют в связке с requestId (генерирует уникальный ключ для экнена),
fulfillWithValue
rejectWithValue - если мы хотим чтобы в результате какого-то определенного ответа от сервера в extraReducers выполнилось действие назнаеченное на fetchPizzasFromRedux.rejected , то надо использовать метод rejectWithValue и передать (что нибудь) в него например текст ошибки(которая пойдет в action.payload), полезно когда много функций с await и удобней дебажить
 -->
<!--
		if (data.length === 0) {
			return thunkAPI.rejectWithValue('Питсы пустые');
		}
		return thunkAPI.fulfillWithValue(data);
		 -->

<!-- ========================================================================================================================================== -->
<!-- Создание селекторов -->
<!-- 17:26 -->
<!-- Это запись и сохранение в переменную (селектор) функуции(изначально мы пишем там анонимную стрелочную ф-цию), которую мы передаем в useSelector -->
<!-- Создаются они в слайсе и потом экспортируются оттуда -->
<!-- Именуя такую функцию принято приписывать selector или select -->

<!-- Прописываем внизу в слайсе -->
<!-- export const selectorCart = (state) => state.cart; -->

<!-- В нужных нам jsx файлах используем новую переменную-->
<!-- 	const { totalPrice, items } = useSelector(selectorCart); -->

<!-- Автоматически должен поддтянуться импорт -->
<!-- import { selectorCart } from '../redux/slices/cartSlice'; -->

<!-- Более сложный вариант -->

<!-- В слайсе мы функцию (state) => state.cart.items.find((obj) => obj.id === id) дополнительно оборачиваем в стрелочную, чтобы иметь возможность передать в нее id в виде параметра из PizzaBlock-->
<!-- export const selectorCartItemById = (id) => (state) => state.cart.items.find((obj) => obj.id === id); -->
<!-- В PizzaBlock у нас:-->
<!--
	const cartItem = useSelector(selectorCartItemById(id));
 -->
 <!-- Автоматически должен поддтянуться импорт -->
 <!-- import { addItem, selectorCartItemById } from '../../redux/slices/cartSlice'; -->

 <!-- Другой вариант -->

<!--  // export const selectorCartItemById =  ( id, state) => state.cart.items.find((obj) => obj.id === id); -->
<!-- 	// const cartItem = useSelector(state =>  selectorCartItemById(id, state)); -->

<!-- ========================================================================================================================================== -->

<!-- Переделываем поиск с контекста на редакс -->
<!-- 34:30 -->
<!-- ========================================================================================================================================== -->
<!-- useLocation  - это хуки из ReactRouter (Там есть еще), для того, чтобы компонент, следящий за window.location и params делал перерисовку при их изменениях -->
<!-- window.location.href - содержит полный текущий адрес и адресной строки абсолютный путь (с http://) -->
<!-- window.location.pathname - содержит адрес внутри сайта (относительный путь, относительно корня) -->
<!-- Проверка соответсвия искомого адреса в адресной строке (window.location.pathname==="/cart") -->
<!-- В реакте компоненты не будут перередериваться по такой проверке, нужно использовать хук useLocation -->

<!-- Добавим скрытие кнопки корзины, когда мы в ней находимся -->
<!-- Создаем переменную location и используем на ней хук, так в ней будет храниться наши данные о локации -->
<!-- 	const location = useLocation(); -->
<!-- импорт хука должен сам подтянуться из react-router-dom -->
<!-- И делаем условный рендер всего что нам нужно показывать/непоказывать {location.pathname !== '/cart' && (<div>Контент</div>)} -->
<!-- 	console.log(location, window.location); location из хука менее объемный, чем через window -->

<!-- Итог: если мы хотим по условному рендеру отображать разный контент, в зависимости от написанного в адресной строке - мы используем useLocation -->
<!-- ========================================================================================================================================== -->

<!-- хук useParams -->

<!-- Создали новый компонент FullPizza в новом файле, это будет отдельная страница для конкретного товара, в нем будет подробное описание товара -->
<!-- Импортируем FullPizza.jsx в Арр.jsx -->
<!-- import FullPizza from './components/FullPizza'; -->
<!-- Добавляем новый роут в App.jsx -->
<!--
					<Route
						path="/pizza/:id"
						element={<FullPizza />}
					/>
 -->
<!-- В строке path чтобы указать какой-либо параметр, нужно поставить не просто "/", а "/:" и дальше придумать и прописать название этого параметра (который будет динамическим) (потом по этому названию мы будем к нему обращаться) (в нашем случае это id)-->
<!-- ":" в path говорит, что дальше идет динамический компонент -->
<!-- Теперь нам нужно вытаскивать это id из массива наших пицц и получить по нему все данные, чтобы выводить их на странице подробного описания -->
<!-- Используем хук в FullPizza 	 -->
<!-- const params = useParams(); -->
<!-- 	console.log(params); -->
<!-- хук useParams возвращает нам объект, содержащий название параметра (которое мы указали в роуте в path):текущее значение параметра -->
<!-- Чтобы добавить еще один динамический параметр, просто пишем его следом снова через "/:" -->
<!-- path="/pizza/:id/:name" -->
<!-- Ну чтобы 404 не вылезла, нужно в строке написать еще этот новый параметр -->
<!-- console.log(params); //{id: '1', name: '2'}//(написали в адресной строке: http://localhost:3000/pizza/1/2) -->
<!-- Нам из всего объета, который возвращает хук нужен только id, мы его и вытащим -->
<!-- 	const { id } = useParams(); -->
<!-- Этот id можем теперь использовать в любом месте нашего приложения -->
<!-- Например вставить в разметку -->
<!-- <h2>{id}</h2> -->
<!-- useParams, как и useLocation делают перерисовку, при изменениях в адресной строке -->

<!-- Теперь сделаем рендер пицц -->
<!-- Заходим на файл, в котором на бэке хранятся данные о нашей пицце -->
<!-- https://64845cf9ee799e3216269459.mockapi.io/items -->
<!-- Обычно бэк предоставляет ссылку для получения одного конкретного товара, нам обычно не нужно запрашивать их все и потом фильтровать -->
<!-- Обычно один роут для всех продуктов и далее передается уточняющий параметр (в нашем случае это id)-->
<!-- В мокапи по кнопке Edit можно увидеть что уже прописано, что по /items/:id выдавать данные -->
<!-- id в json файле должен быть в виде строке (мокапи делает строгую проверку) -->
<!-- По адресу ниже мы получим с бэка данные пиццы с id = 5 -->
<!-- https://64845cf9ee799e3216269459.mockapi.io/items/5 -->

<!-- Теперь сделаем отображение на странице полученных таким образом данных -->
<!-- Создаем стейт, в котором будет хранится текущая пицца -->
<!-- 	const [pizza, setPizza] = React.useState(); -->

<!-- Пишем запрос -->
<!-- 	React.useEffect(() => {
		axios.get('https://64845cf9ee799e3216269459.mockapi.io/items/' + id);
	}, []); -->
<!-- Вытаскивать будем через try catch -->

<!-- Функцию, которую мы передаем первым аргументом в useEffect нельзя делать async, но можно создать async функцию внутри нее и уже в новой внутренней функции использовать await  -->

<!--
	React.useEffect(() => {
		async function fetchPizza() {
			try {
				const { data } = await axios.get('https://64845cf9ee799e3216269459.mockapi.io/items/' + id);
				setPizza(data);
			} catch (error) {
				alert('Не удалось получить подробное описание');
			}
		}
		fetchPizza();
	}, [id]);
 -->

<!-- У нас возникнет ошибка, что pizza = undefined, потому что запрос еще не получил ответ, а мы уже пытаемся отрендерить данные из ответа, поэтому - ошибка, код останавливается и запрос вообще не выполняется, сделаем условный рендер, если данные еще не получены - ничего не рендерить -->

<!--
	if (pizza) {
		return (
			<div className="container">
				<img
					src={pizza.imageUrl}
					alt=""
				/>
				<h2>{pizza.title}</h2>
				<p>
					Lorem, ipsum dolor sit amet consectetur adipisicing elit. Nobis, error deserunt veritatis quam
					aspernatur non necessitatibus reiciendis impedit? Enim, quisquam ducimus. Obcaecati quia, fugit
					facere cupiditate placeat magnam tenetur blanditiis.
				</p>
				<h4> {pizza.price} </h4>
			</div>
		);
	} else {
		return 'Загрузка';
	}
 -->

<!-- Делаем отображение нужной пиццы в отдельном окне по клику -->
<!-- В Home.jsx находим переменную, которая содержит массив объектов-карточек пицц, и вешаем Link (не забываем его импортировать из реакт-роутер-дом) на каждую карточку, чтобы по клику на нее переходить к подробному описанию, key при этом нужно перенести в Link, т.к. он теперь родитель для списка -->

<!--
	const pizzas = items.map((obj) => (
		<Link
			key={obj.id}
			to={`/pizza/${obj.id}`}
		>
			<PizzaBlock {...obj} />
		</Link>
	));
 -->

<!-- Но -->

<!-- У меня мозгов хватило обернуть только картинку пиццы в Link, в PizzaBlock, тогда при клике на другие области карточки, мы не переходим на страницу с подробностями -->

<!--
				<Link to={`/pizza/${id}`}>
					<img
						className="pizza-block__image"
						src={imageUrl}
						alt="Pizza"
					/>
				</Link>
 -->
 <!-- Теперь мы запрашиваем с бэка и получаем конкретную пиццу -->
 <!-- useParams мы используем чтобы компонент перерисовался и передал нам динамические параметры (вытащенные из адресной строки)-->

<!-- Опишем всю логическую цепочку:  -->
<!-- В App.jsx мы указали роут , если у тебя будет путь типа: path="/pizza/:id",где id - некий динамический параметр, то рендери FullPizza -->
<!-- Когда теперь мы нажимаем на картинку пиццы, то в PizzaBlock.jsx срабатывает переход <Link to={`/pizza/${id}`}> , сдесь id уже берется из пропсов PizzaBlock конкретной пиццы, (в PizzaBlock же они попали из Home.jsx, когда мы массив пицц с бэка обходили с помощью map. И у нас адресная строчка заполняется теперь : /pizza/"айди питсы"-->
<!-- Дальше в FullPizza с помощью хука useParams мы этот id достаем из адресной строки и записываем в одноименную переменную. И потом используем ее с помощью конкатенаци, чтобы сделать запрос на бэк, который готов по таким запросам предоставлять данные об одном конкретном товаре-->
<!-- Потом мы эти данные извлекаем, записываем в переменную и эту переменню присваиваем стейту pizza. Ну а дальше в разметке мы из этого стейта достаем все что нужно {pizza.title}, {pizza.imageUrl} и т.д-->

<!-- Чтобы вытасткивать обычные (те которые после ? идут) а не динамические параметры нужно использовать useSearchParams или в window.location.search или с помощью свойства search, которое хранится в location, когда мы используем useLocation, в котором и будут содержаться все параметры -->
<!-- ========================================================================================================================================== -->
<!-- 39:50  Аутлет <Outlet />-->

<!-- Аутлет нужен, чтобы отображать в нем как в контейнере динамически изменяющийся контент в зависимости от пути в адресной строке, при том что часть контента  на странице будет статичной (шаблон) независимо от пути в адресной строке (т.е. присутствовать на всех роутах) (это может быть хедер или меню) -->
<!-- Для этого создаем сам jsx шаблон (у нас это MainLayout) внутри него в нужном месте вставляем компонент <Outlet />.
Не забываем импортировать компонент Outlet туда, где мы его используем.
import { Outlet } from 'react-router-dom';
 Далее в App.jsx создаем родительский роут с элементом-шаблоном и далее пишем дочерние роуты (одновременно будет отображаться только один из них), все их содержимое таким образом будет подставляться вместо компонента <Outlet /> и отображаться внутри шаблона. А уж что именно будет зависеть от пути в адресной строке  -->
<!--
			<Route
				path="/"
				element={<MainLayout />}
			>
 -->
<!-- App.jsx теперь будет выглядеть так -->
<!--
function App() {
	return (
		<Routes>
			<Route path="/" element={<MainLayout />}>
				<Route path="" element={<Home />} />
				<Route path="/123" element={<h1>123</h1>} />
				<Route path="/cart" element={<Cart />} />
				<Route path="/pizza/:id" element={<FullPizza />} />
				<Route path="*" element={<NotFound />} />
			</Route>
		</Routes>
	);
}
 -->

 <!-- Такой способ нужен чтобы реакт-роутер-дом корректно все рендерил, считывал параметры и применял хуки. Особенно это становится важно когда роутов много и они имеют глубокую вложенность -->

 <!-- useNavigate - хук из 'react-router-dom' , который возвращает функцию в параметрах который нужно указать относительный адрес и он как бы сделает диспатч в адресную строку и перенесет пользователя в указанное место на сайте-->

 <!-- Вытаскиваем хук -->
<!-- import { useNavigate } from 'react-router-dom'; -->
<!-- Создаем на его основе функцию  -->
<!-- 	const navigate = useNavigate(); -->
<!-- Используем, чтобы перенести пользователя на главную, случае ошибки, полученной с бэка : 				navigate('/'); -->
<!--
	React.useEffect(() => {
		async function fetchPizza() {
			try {
				const { data } = await axios.get('https://64845cf9ee799e3216269459.mockapi.io/items/' + id);
				setPizza(data);
			} catch (error) {
				alert('Не удалось получить подробное описание');
				navigate('/');
			}
		}
		fetchPizza();
	}, [id]);
 -->

<!-- ========================================================================================================================================== -->
<!-- #15: 🍕 React Pizza v2 — Сохраняем параметры фильтрации в URL -->
<!-- При изменении параметров фильтрации и сортировки будем менять url -->

<!-- Ставим библиотеку QS (querystring)-->
<!-- npm i qs -->
<!-- Позволяет спарсить или сгенерировать параметры запроса -->
<!-- Парсер/генератор строки запроса, поддерживающий вложенность и массивы, с ограничением глубины.. -->
<!-- Импортируем qs в Home.jsx -->
<!-- import qs from 'qs'; -->
<!-- Создаем отдельный useEffect,который будет отвечать за парсинг запросов и вшивание их в адресную строку -->

<!--
React.useEffect(()=>{

},[activeCategory, sortType, searchValue, currentPage])
 -->

<!-- Пишем логику: если к нам пришли какие-то параметры - то мы должный превратить их в одну целую строчку -->
<!-- Воспользуемся методом библиотеки qs qs.stringify - он преобразовывает переданный объект в строку-->

<!--
React.useEffect(()=>{
const queryString = qs.stringify({

})
},[activeCategory, sortType, searchValue, currentPage])
 -->

 <!-- Составляем этот объект из наших данных из store -->

 <!-- 
 	React.useEffect 
		(() => {
			const queryString = qs.stringify({
				sortProperty: sortType.sortProperty,
				activeCategory: activeCategory,
				currentPage: currentPage,
			});
			console.log(queryString)
		},
		[activeCategory, sortType, searchValue, currentPage]);
  -->
<!-- Сморим что вернет нам 		console.log(queryString) -->
<!-- //sortProperty=rating&activeCategory=0&currentPage=1 -->
<!-- Т.о. образом мы генерируем строку из наших параметров, такую же как отправляем в виде запроса на бэк -->
<!-- Передаем объект-получаем строку -Круто! -->
<!-- При смете параметров соответсвенно будет меняться сгенерированная строка -->
<!-- Теперь эту строку нам нужно вшивать в адресную строку -->
<!-- Для этого используем хук useNavegate из реакт-роутер-дом -->
<!-- Вытаскиваем хук в функцию -->
<!-- 	const navigate = useNavigate(); -->
<!-- Импорт должен сам подтянуться -->
<!-- import { useNavigate } from 'react-router-dom'; -->
<!-- Вызываем функцию внутри useEffect из хука, не забывая добавить "?" перед основной строкой с параметрами, т.к. в адресной строке он нужен, а queryString его не содержит -->
<!--navigate(`?${queryString}`);  -->
<!--
	React.useEffect(() => {
		const queryString = qs.stringify({
			sortProperty: sortType.sortProperty,
			activeCategory: activeCategory,
			currentPage: currentPage,
		});
		navigate(`?${queryString}`);
	}, [activeCategory, sortType, searchValue, currentPage]);
 -->

<!-- Теперь сделаем обратную операцию: будем парсить параметры из адресной строки и составлять из них объект -->

<!-- Для этого можно использовать хук useSearchParams из реакт-роутер-дом или window.location.search -->
<!-- Этот useEffect располагаем перед всеми другими и перед всеми переменными, полученными из редакса -->
<!-- Парсим адресную строку при первом рендере, используя библиотеку qs и ее метод parse. Чтобы "?" убрать из начала используем substring(1) -->
<!--
	React.useEffect(()=>{
	const params =qs.parse(window.location.search.substring(1))
	console.log(params)
	},[])
 -->
 <!-- Теперь у нас в params параметры, которые мы спарсили из адресной строки в виде объекта -->
 <!-- 
 //{sortProperty: 'rating', activeCategory: '0', currentPage: '1'}
  -->
<!-- Теперь эти параметры нужно передавать в редакс, чтобы он в соответсвии с ними диспатчил и перерисовывал страницу -->

<!-- Для этого делаем новый метод setFilters в filterSlice -->
<!--
		setFilters(state, action) {
			//Измени стейт и Запиши в currentPage то что будет в переданном объекте в свойстве currentPage, предварительно преобразовав это в число
			state.currentPage = Number(action.payload.currentPage) ;
			state.activeCategory = Number(action.payload.activeCategory) ;
			state.sortType= action.payload.sortType;
		},
 -->
 <!-- не забываем его экспортировать -->
 <!-- 
 export const { setActiveCategory, setActiveSortType, setCurrentPage, setSearchValue, setFilters } = filterSlice.actions;
  -->
<!-- Вытаскиваем новый метод из слайса -->
<!-- import { setActiveCategory, setCurrentPage, setFilters } from '../redux/slices/filterSlice'; -->
<!-- И в том же месте, где мы парсим - мы диспатчим в стейт параметры сразу в деструктурированном виде ( в виде объекта, а не переменной )({...params} написали вместо{currentPage,activeCategory,sortProperty }), которые спарсили из адресной строки -->
<!--
	React.useEffect(()=>{
	const params =qs.parse(window.location.search.substring(1))
	dispatch(setFilters({...params}))
	},[])
 -->
<!-- Но у нас в params содержится sortProperty в виде строки, а в слайсе у нас объект : -->
<!-- sortType: { name: 'популярности (сначала популярные)', sortProperty: 'rating' } -->
<!-- Поэтому чтобы задиспатчить нам нужно сгенерировать объект для слайса на основе данных, полученных из params -->
<!-- Для этого мы экспортируем переменную с массивом объектов list из Sort.jsx -->
<!--
export const list = [
	{ name: 'популярности (сначала популярные)', sortProperty: 'rating' },
	{ name: 'популярности (сначала непопулярные)', sortProperty: '-rating' },
	{ name: 'цене (сначала дороже)', sortProperty: 'price' },
	{ name: 'цене (сначала дешевле)', sortProperty: '-price' },
	{ name: 'алфавиту (А-Я)', sortProperty: '-title' },
	{ name: 'алфавиту (Я-А)', sortProperty: 'title' },
];
 -->
 <!-- В Home.jsx мы его импортируем  -->
<!-- import { list } from '../components/Sort'; -->
<!-- Далее непосредственно перед диспатчем мы будем по этому массиву пробегаться и находить в нем объект в котом свойство sortProperty совпадает с тем что у нас в адресной строке в sortProperty. Найденный объект записываем в переменную sortType (как и свойство из которого мы хотим доставать этот объект внутри setFilters в слайсе) и передаем в слайс в редакс вместе с params -->
<!-- 		const sortType = list.find((obj) => obj.sortProperty === params.sortProperty); -->
<!-- Получится в итоге так -->
<!--
	React.useEffect(() => {
		const params = qs.parse(window.location.search.substring(1));
		const sortType = list.find((obj) => obj.sortProperty === params.sortProperty);
		//console.log(params, sortType);
		dispatch(setFilters({ ...params, sortType }));
	}, []);
 -->

<!-- Все работает, но у нас происходит 2 отрисовки: первоначальная и потом уже по заполненным параметрам. (А у меня без параметров только фон видно, обновление страницы помогает и тогда 2 запроса отправляются) Исправляем, чтобы у нас был один запрос и соответсвенно отрисовка независимо от того есть у нас параметры или нет. -->

<!-- Этот юзЭффект делает 1 запрос -->
<!--
	React.useEffect(() => {
		fetchPizzas();
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [activeCategory, sortType, searchValue, currentPage]);
 -->

<!-- И загрузит приложение с первоначальными параметрами -->

<!--
const initialState = {
	sortType: { name: 'популярности (сначала популярные)', sortProperty: 'rating' },
	activeCategory: 0,
	currentPage: 1,
	searchValue: '',
};
 -->

 <!-- После первой отрисовки он смотрит в адресную строку, видит там параметры и делает новый запрос уже по параметрам из адресной строки, которые заменили предыдущие в редаксе -->

 <!-- Сделаем чтобы даже если нет параметров был только один запрос -->

<!-- Сделаем так, чтобы запрос на бэк не отправлялся до тех пор пока параметры из url не задиспатчатся в редакс -->
<!-- т.е. при первом рендере нужно сделать проверку на необходимость отправки запроса. Если пришли параметры => не отправляй запрос до диспатча. Если параметров нет => диспатч не отравится => отправляй запрос  -->

<!-- Делаем флаг. Он будет сигнализировать о том есть ли в адресной строке параметры, которые мы в редакс записали.(по умолчанию - нет) Благодаря хуку useRef в isSearch.current всегда будет храниться актуальное состояние переменной.(независимо от перерисовок) По умолчанию будет false -->
<!-- const isSearch = React.useRef(false); -->

<!-- Пишем условие на запуск useEffect - наличие параметров в строке поиска -->
<!--  <!-- window.location.search - вернет нам все параметры что написаны в адресной строке после первого / включая "?" вначале --> -->
<!-- Ставим это флаг в true, в момент сразу после диспатча параметров в редакс -->
<!--
	React.useEffect(() => {
		if (window.location.search) {
			const params = qs.parse(window.location.search.substring(1));
			const sortType = list.find((obj) => obj.sortProperty === params.sortProperty);
			// console.log(params, sortType);
			dispatch(setFilters({ ...params, sortType }));
			isSearch.current = true;
		}
		// eslint-disable-next-line
	}, []);
 -->
 <!-- Этот useEffect должен идти самым первым, и если адрсная строка пуста-то диспатч не отработает и isSearch.current останется false. т.к по умолчанию -->
 <!-- const isSearch = React.useRef(false); -->
 <!-- И тогда следующий useEffect по состоянию флага поймет отправлять запрос или нет. Если isSearch.current = false, значит - параметров в url нет => отправляем запрос . А если isSearch.current = true, запрос не отработает и переключаем флаг isSearch.current = false (как по умолчанию) чтобы при перерендере (когда мы будем параметры менять) запрос отправлялся -->
<!--
	React.useEffect(() => {
		window.scrollTo(0, 0);
		if (!isSearch.current) {
			fetchPizzas();
		}
		isSearch.current = false;
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [activeCategory, sortType, searchValue, currentPage]);
 -->

<!-- Все круто работает. И запрос отпраляется только один и при первоначальной загрузке все сразу корректно рендерится. И без параметров тоже все корректно. -->
<!-- Но есть проблема. При перезапуске приложения (обновлении страницы) параметры (если они были) автоматически вшиваются старые в адресную строку -->
<!-- Дело в том что  useEffect при первом рендере сразу смотрит в редаксе параметры и вшивает их в url, даже если они не изменялись пользователем -->
<!--
	React.useEffect(() => {
		const queryString = qs.stringify({
			sortProperty: sortType.sortProperty,
			activeCategory: activeCategory,
			currentPage: currentPage,
		});
		// console.log(queryString);
		navigate(`?${queryString}`);
		// eslint-disable-next-line
	}, [activeCategory, sortType, searchValue, currentPage]);
 -->
<!-- Сделаем так чтобы при первом рендере никакие параметры не вшивались в url. Если же перерендер произошел из-за изменения параметров пользователем - тогда вшивай. -->
<!-- Делаем флаг. Он будет хранить инфорамацию о том, что уже произошел первый рендер. -->
<!-- 	const isMounted = React.useRef(false); -->
<!-- Пишем условие для useEffect. И ставим флаг в true только после всех действий useEffect. Тут мы уже точно уверены что самый первый рендер произошел, переменная с помощью useRef хранит данные независимо от перерендеров, и когда уже будут изменения в параметрах со стороны пользователя параметры будут вшиваться в url  -->

<!--
	React.useEffect(() => {
		if (isMounted.current) {
			const queryString = qs.stringify({
				sortProperty: sortType.sortProperty,
				activeCategory: activeCategory,
				currentPage: currentPage,
			});
			// console.log(queryString);
			navigate(`?${queryString}`);
		}
		isMounted.current = true;
		// eslint-disable-next-line
	}, [activeCategory, sortType, searchValue, currentPage]);
 -->

<!-- ========================================================================================================================================== -->
<!-- Typescript -->
<!-- Для нового проекта -->
<!-- npm install --save typescript @types/node @types/react @types/react-dom @types/jest
 -->
 <!-- Для существующего проекта -->
<!-- npm install --save typescript @types/node @types/react @types/react-dom @types/jest
 -->

<!-- Фиксим index.tsx -->

 <!-- 
 const rootElem = document.getElementById('root');

if (rootElem) {
	const root = ReactDOM.createRoot(rootElem);
	root.render(
		<Provider store={store}>
			<BrowserRouter>
				{/* <React.StrictMode> */}
				<App />
				{/* </React.StrictMode> */}
			</BrowserRouter>
		</Provider>,
	);
}
  -->
<!-- ========================================================================================================================================== -->
<!-- #22: 🍕 React Pizza v2 — Типизируем пропсы (props) и хук useRef (TypeScript) -->

<!-- Чтобы TS понимал другие расширения : -->
<!-- Создаем файл *.d.ts. (custom.d.ts/assets.d.ts) В нем будут прописаны глобальные типы. Принято все файлы, которые относятся к типизации (кастомные типы) хранить в папке @types в src -->
<!-- В нем декларируем типы -->
 <!-- 
declare module '*.svg' {
	const content: any;
	export default content;
}

declare module '*.png' {
	const content: any;
	export default content;
}

declare module '*.scss' {
	const content: any;
	export default content;
}

declare module 'lodash.debounce' {
	const content: any;
	export default content;
}
  -->
<!-- В tsconfig.json добавляем нашу папку -->
<!--
"include": ["src", "src/@types"]
 -->

                                                            <!-- Типизация компонентов -->
<!-- Функциональные компоненты имеют тип React.FC. Указыаем его даже если у него нет пропсов -->
<!--
const EmptyCart: React.FC = () => {
	return (
		<div className="content"></div>
		)}
 -->


                                                          <!-- Типизация параметров -->
<!-- Типизация для параметров функции указыается прямо в (), когда мы указываем сами параметры -->
<!--
	const totalCount = items.reduce((sum: number, item: any) => {
		return sum + item.count;
	}, 0);
 -->

                                                              <!-- Автотипизация -->
<!--
export const list = [
	{ name: 'популярности (сначала популярные)', sortProperty: 'rating' },
	{ name: 'популярности (сначала непопулярные)', sortProperty: '-rating' },
	{ name: 'цене (сначала дороже)', sortProperty: 'price' },
	{ name: 'цене (сначала дешевле)', sortProperty: '-price' },
	{ name: 'алфавиту (А-Я)', sortProperty: '-title' },
	{ name: 'алфавиту (Я-А)', sortProperty: 'title' },
];
 -->
<!-- Если навести на list в месте где мы ее объявляем (выше), то появится всплывающая подсказка, что редактор вкурсе, что list - это массив объектов, в каждом из которых есть свойсто name и sortProperty и они оба имеют тип строка :-->
<!--
const list: {
	name: string;
	sortProperty: string;
}[]
 -->

                                                              <!-- Кастомные типы -->

 <!-- Можно создать свой кастомный тип (объект с определенными свойствами) и назначить его переменной, тогда ей нельзя будет присвоить другие/лишние свойства -->
 <!-- 
 type SortItem = {
	name: string;
	sortProperty: string;
};
  -->
<!-- Тип как и любую переменную можно переиспользовать -->
<!-- Тип создан, теперь присваиваем его, и не просто присваиваем, а говорим что переменная - это массив объектов назначенного типа -->
<!--
export const list: SortItem[] = [
	{ name: 'популярности (сначала популярные)', sortProperty: 'rating' },
	{ name: 'популярности (сначала непопулярные)', sortProperty: '-rating' },
	{ name: 'цене (сначала дороже)', sortProperty: 'price' },
	{ name: 'цене (сначала дешевле)', sortProperty: '-price' },
	{ name: 'алфавиту (А-Я)', sortProperty: '-title' },
	{ name: 'алфавиту (Я-А)', sortProperty: 'title' },
];
 -->

<!-- Без создания костомного типа эта запись выглядела бы так: -->

<!--
export const list: {
	name: string; 
	sortProperty: string;
}[] = [
	{ name: 'популярности (сначала популярные)', sortProperty: 'rating' },
	{ name: 'популярности (сначала непопулярные)', sortProperty: '-rating' },
	{ name: 'цене (сначала дороже)', sortProperty: 'price' },
	{ name: 'цене (сначала дешевле)', sortProperty: '-price' },
	{ name: 'алфавиту (А-Я)', sortProperty: '-title' },
	{ name: 'алфавиту (Я-А)', sortProperty: 'title' },
];
 -->
<!-- Лучше не создавать типы содержащие множество. Лучше создать тип - единичную сущность, а уже где нужно превращать ее в множество с помощью [] .-->

                                                              <!-- Типизация хука useRef -->
<!-- const sortRef это ссылка на html элемент, значит она должна быть либо html элементом, либо null. Изначально useRef() это 'MutableRefObject<undefined>' (MutableRefObject, который по умолчанию undefined), но у него должно быть вшито, что либо он принимает какой-то элемент, либо null -->
<!-- Чтобы типизировать хук нужно открыть <> между названием хука и () и в <> прописать тип, который мы хотим получить по ссылке. Узнать этот тип можно наведя курсором на тэг элемента в разметке (тип будет указан в сам конце всплывающего окна, после последней запятой) для div это <HTMLDivElement> , а для svg <SVGSVGElement>. Обязательно по умолчанию нужно указать (null), т.к. разметка рендерится с задержкой. Если в () ничего не указыать, то по умолчанию там будет undefined, что недопустимо: useRef в TS не разрешает хранить undefined  -->

<!-- 	const sortRef = useRef<HTMLDivElement>(null); -->

<!-- Теперь sortRef ожидает получить от useRef - HTMLDivElement, но если не получится то получит null -->

                                                              <!-- Типизация пропсов -->

<!-- Для компонентов лучше создавать их через const, чем через function. Для компонентов созданных через function нельзя присвоить тип так: (function Categories: React.FC<CategoriesProps>) - будет ошибка -->
<!-- Чтобы типизировать пропсы для компонента - указыаем ему тип (: React.FC) после названия типа открываем <> и прописываем объект(потому что наши пропсы находятся внутри объекта), где ключи - это пропсы, значения - их типы. Также можно создать кастомыный тип и переиспользовать его   -->

<!-- 
type CategoriesProps = {
	activeCategory: number;
	onClickSetActiveCategory: any;
};
const Categories: React.FC<CategoriesProps> = ({ activeCategory, onClickSetActiveCategory }) => {...}
 -->

<!-- 
	// Вариант типизации похуже
// const Categories: React.FC = ({ activeCategory, onClickSetActiveCategory }: CategoriesProps) => {...}
 -->


                                                              <!-- Типизация useState -->
<!-- Его можно не типизировать, он будет типизирован автоматически -->
<!-- 	const [activeSize, setActiveSize] = React.useState(0); -->
<!-- Но если очень хочется то можно -->
<!-- Для этого пишем тип в <> между названием хука и () -->
<!-- <!-- 	const [activeSize, setActiveSize] = React.useState<number>(0); --> -->
<!-- ========================================================================================================================================== -->
<!-- lodash типизация не хочет устанавливаться поэтому мы просто добавили ее в d.ts -->
<!-- ========================================================================================================================================== -->
                                                              <!-- Вызов по возвращенному типу -->
<!-- в Search.jsx у нас есть inputRef, типизируем его как обычно типизируем хуки -->
<!-- 	const inputRef = React.useRef<HTMLInputElement>(null); -->
<!-- Но мы потом вызываем метод focus() на его дочерний элемент, и если inputRef вернет null, то его дочерние элементы будут undefined, а у undefined нет метода focus(). Будет краш. Чтобы этого избежать мы используем оператор "?." (optional chaining - оператор опциональной последовательности. Его даже можно ставить между методом и его вызовом - ().
Например: inputRef.current?.focus?.()
 Он говорит, если слева не undefined/null выполняй то что справа, если undefined/null - не ломай приложение) после элемента на который хотим вызвать метод. -->
<!-- inputRef.current?.focus() -->
<!-- Теперь если в inputRef - null, то focus() не будет вызываться -->
<!-- Также можно сделать проверку операторами сравнения (if) или &&-->

                                                              <!-- Игнорирование ошибок в TS -->

<!-- Для игнорирования ошибки пишем выше нее комментарий // @ts-ignore-->
<!-- 
		dispatch(
			// @ts-ignore
			fetchPizzasFromRedux({
				category,
				sort,
				order,
				filter,
				currentPage,
			}),
		);
 -->

 <!-- если не знаем какой тип использовать можно написать any, чтобы не крашилось -->
 <!-- Все это понятно плохая практика и можно ей пользоваться только при необходимости в процессе разработки -->


                                                              <!-- Типизация функций -->
<!-- Чтобы типизировать функцию после : указываем стрелочную функцию, указываем какие аргументы она должна получить и каких они типов, а после => указываем что она должна вернуть (void - означает что ничего не возвращает) -->

<!-- 
type CategoriesProps = {
	activeCategory: number;
	onClickSetActiveCategory: (i:number) => void;
};
 -->

<!-- 
// void означает, что функция не требует возвращения при помощи return например, т.е. ничего не вернет
// () => void - означает что функция просто должна вызываться (без аргументов)
// (i:number) => void; - означает что функция ничего не вернет, но должна получить 1 аргумент типа number (названия аргументов, не важны вовсе)
// onClickSetActiveCategory - является обязательной для использования, нельзя про нее просто забыть и не вызвать
// чтобы сделать функцию опциональной для использования нужно использовать "?" между названием функции и ":"
// например
// onClickSetActiveCategory?: (i:number) => void; 

// Но теперь функция onClickSetActiveCategory потенциально может быть undefined и TS на это ругается, 
// (в Home.tsx)
// onClick={() => {
// 	onClickSetActiveCategory(index);
// }}

// => надо делать проверку if на отсутсвие undefined или с помощью ?.

// onClickSetActiveCategory?.(index)
 -->

<!-- Суть типизации функций такая: мы создаем независимую сущность, и остальные сущности для взаимодействия с функцией должны под нее подстраиваться, т.е. передавате в функцию и принимать от нее заданные типы, а не функцию должна подстраиваться  -->
<!-- Компоненты более высоких уровней должны подстраиваться под компоненты более низких уровней -->

<!-- Цепочка типизации: Мы создали кастомный тип и типизировали в нем функцию, типизировали компонент и его пропсы теперь, когда мы вытащим эту функцию из пропсов, мы будем уверены что она будет соответсвовать своей типизации, и далее эта функция будет использоваться в нужном месте (в нашем случае в разметке) и передать ей мы сможем только параметры указанные при типизации  -->
<!-- Если же мы теперь попытаемся вызвать функцию без параметров, то получим ошибку -->


<!-- ========================================================================================================================================== -->
                                                              <!-- Типизация event (onChange, onClick) -->
<!-- Идем в Search.tsx -->
<!-- 	const onChangeInput = (event: React.ChangeEvent<HTMLInputElement>) => { -->
<!-- 
		// Чтобы типизировать event для реакта пишем для onChange (для изменения input, textArea) : React.ChangeEvent<...>, где в <...> указываем элемент, (в котором произошло событие) который отправляет event (в нашем случае это HTMLInputElement)(чтобы узнать какой это элемент наводим в разметке на onChange в месте вызова функции использующей event)

<!-- 
			<input
				ref={inputRef}
				value={value}
				className={styles.input}
				onChange={onChangeInput}
				type="text"
				placeholder="Поиск пицц..."
			/>
 -->

<!-- 		// Для event на события мыши (onClick) пишем :React.MouseEvent<...>, где в <...> указываем элемент, который отправляет event
		// например
		// const clearInput = (event: React.MouseEvent<HTMLImageElement>) => {
		// Для JS пишем просто Event -->

                                                              <!-- Опциональные параметры -->
<!-- type PaginationBlockProps = { onChangePage: (page: number) => void }; -->
<!-- 
// onChangePage это у нас функция, которая должна получить аргумент page, который является number и ничего не вернуть
// Можно оставить вызов функции обязательными, сделать передачу параметров опциональными. Также испольузуется ? перед :
// type PaginationBlockProps = { onChangePage: (page?: number) => void };
 -->
                                                               <!-- as в TS -->
<!-- as - называется Type Assertion. он просто указывает компилятору рассматривать что-то как тип (переопределяет тип)-->
<!-- 
var a = 'TEST STRING'
var b = a as string; //Означает, что компилятор предположит, что это строка

Также в качестве указываемого типа можно использовать кастомный

 -->

                                                                <!-- composedPath() для MouseEvent в TS -->
<!-- Идем в Sort.tsx -->

<!-- Изначально у типа MouseEvent нет свойства composedPath()  -->
<!-- Если мы хотим прикрутить к какому либо типу еще какую-то часть мы используем & и дальше в {} пишем что хотим добавить это что-то вроде конкатенации для типов в TS-->
<!-- Создаем кастомный тип, в нем добавляем свойство при помощи &  -->
<!-- 
		type popupCloserEvent = MouseEvent & {
			composedPath: Node[];
		};
 -->
 <!-- т.е. мы говорим тип popupCloserEvent это тип MouseEvent плюс то что внутри фигурных скобок {} -->
 <!-- Теперь внутри функции popupCloser мы создаем _event, который является тем же event, но имеет наш кастомный тип - popupCloserEvent -->
 <!-- const _event = event as popupCloserEvent; -->
 <!-- И дальше в функции мы используем именно _event-->
 <!-- Добавляем проверку на наличие sortRef.current -->
<!-- В итоге код имеет вид -->
 <!-- 
 
	React.useEffect(() => {

		type popupCloserEvent = MouseEvent & {
			composedPath: Node[];
		};
		
		const popupCloser = (event: MouseEvent) => {
			const _event = event as popupCloserEvent;
			if (sortRef.current && !_event.composedPath().includes(sortRef.current)) {
				setIsShow(false);
			}
		};

		window.document.body.addEventListener('click', popupCloser);

		return () => {
			window.document.body.removeEventListener('click', popupCloser);
		};
	}, []);

  -->

<!-- Теперь addEventListener и removeEventListener отправляют в popupCloser обычный MouseEvent, и функция popupCloser его ожидает. При этом нам доступно свойство composedPath() у _event потому что мы сказали ему использовать объект event как кастомный тип popupCloserEvent, в котором уже composedPath() был добавлен-->



																															<!-- Типизация в RTK -->
																							подробнее								<!-- https://redux-toolkit.js.org/usage/usage-with-typescript -->
<!-- Конвертируем все файлы редакса в ts -->

<!-- Нужно типизировать стор, слайсы, стейты, экшены, асинхронные экшены. -->

																															<!-- Типизация initialState -->
<!-- Идем в cartSlice -->
<!-- у state.items тип never[], т.к. если не указать тип для initialState, но будет браться тип из содержимого. В initialState указано items:[], т.е. массив чего угодно-->

<!-- Вспоминаем что такое items. Это массив CartItem. По названию метода addItem находим в CartItem. Присваиваем тип каждому из его ключей  -->



<!-- 
type CartItemProps = {
	id: string;
	title: string;
	price: number;
	imageUrl: string;
	size: number;
	type: string;
	count: number;
};

const CartItem: React.FC<CartItemProps> = ({ id, title, price, imageUrl, size, type, count }) => {
 -->

<!-- Создаем кастомный тип в cartSlice для items -->
<!-- 
type TCartItem = {
	id:string,
	title:string,
	price:number,
	imageUrl:string,
	size: number,
	type: string,
	count: number;
}
 -->

<!-- Обычно когда типизируют state его делают через interface -->
<!-- interface выполняет теже функции, что и type, но применить его можно только к объектам. Его стараются применять когда типизируются объекты с многоуровневой вложенностью. Также interface имеет возможность расширять (extends) уже созданные interface (т.е. создавать новые на основе предыдущих); и (implements)(реализация интерфейса)  Для типизации без вложенностей чаще используют type. ВАЖНО!!! Для декларации через interface знак "=" не пишется -->

<!-- 
interface CartSliceState {
totalPrice: number;
items: TCartItem[]
}
 -->

<!-- Теперь говорим что initialState имеет тип CartSliceState -->
<!-- 
const initialState: CartSliceState = {
	items: [],
	totalPrice: 0,
};
 -->

 <!-- Теперь items имеет тип TCartItem[] -->

 <!-- При этом типизировался весь state. Потому что createSlice автоматически взял тип state из initialState и пропихнул его везде куда нужно -->

 <!--если навести на state мы увидим что он - WritableDraft это уже относится к immerJS -->


                                                    <!-- Типизация initialState в filterSlice -->

<!-- Пропишем типы для каждого state, но sortProperty сделаем не просто string, а чтобы он мог принимать только определенные строковые значения  -->

<!-- 
interface IFilterSliceState {
	sortType: {
		name: string;
		sortProperty: 'rating' | 'price' | 'title' | '-rating' | '-price' | '-title';
	};
	activeCategory: number;
	currentPage: number;
	searchValue: string;
}

const initialState: IFilterSliceState = {
 -->
 
<!-- Ну или можно создать для sortType кастомный тип -->

 <!-- 
 type TSortProperty = {
	name: string;
	sortProperty: 'rating' | 'price' | 'title' | '-rating' | '-price' | '-title';
};

interface IFilterSliceState {
	sortType: TSortProperty;
	activeCategory: number;
	currentPage: number;
	searchValue: string;
}

const initialState: IFilterSliceState = {
  -->

                                                    <!-- Типизация initialState в pizzaSlice -->

<!-- для status позволяем передать только 1 из трех статусов в строкового типа, для items создаем кастомный тип PizzaItem, обычно для типизации объектов, полученных с бэка - мы лезем в бэк и смотрим на этот объект, копируем его себе и меняем значения на типы (преобразуем ответ в тип), но в данном случае мы это уже сделали в PizzaBlock.tsx. Берем оттуда type PizzaBlockProps и вставляем себе, называя его PizzaItem. Не забываем, что items - это массив PizzaItem (PizzaItem[]). И не забываем указать тип собственно для initialState (const initialState: IPizzaSliceState) -->

<!-- 
type PizzaItem = {
	id: string;
	title: string;
	price: number;
	imageUrl: string;
	sizes: number[];
	types: number[];
};

interface IPizzaSliceState {
	items: PizzaItem[];
	status: 'loading'|'success'|'error';
}

const initialState: IPizzaSliceState = {
	items: [],
	status: 'loading',
};
 -->

																															<!-- interface (implements)(реализация интерфейса)-->

<!-- interface - это понятие из ООП и оно нужно чтобы избегать проблемы множественного наследования (наследование - создание более специфичного типа на основе уже существующего) (множественное наследование - наследование одновременно от двух или нескольких классов.) Проблема множественного наследования в том, что в одном и другом классе может быть реализация одного и того же свойства, в результате непонятно какая из этих реализация будет унаследована дочерним классом-->
<!-- interface же - это полностью абстрактный класс, в котором могут быть только объявления без конкретных реализаций. А реализацию мы уже создаем в классе. 
Получается что если в двух interface будут 2 метода, то т.к. нет никакой реализации, то мы просто берем и реализовываем этот метод уже в классе. Т.о. мы можем использовать interface для множественного наследования. type - это просто тип, никакого наследования в нем нет.
 -->

																															<!-- ImmerJS с ReactJS-->

<!-- immer - это библиотека, включенная в RTK, благодаря которой наши непримитивы ([] и {}) нельзя будет мутировать напрямую -->
<!-- мутация - изменение значения свойства объекта -->
<!-- В js обычно мутации происходят с помощью точечной записи -->

<!-- например -->

<!-- 
const user = { name: "Вася"};
user.name = "Василий"
 -->

 <!-- также мутируют и state -->

 <!-- immer позволяет запретить мутировать объект -->

<!-- 
mutable - изменяемый;
immutable - неизменяемый
 -->

<!-- immer работает так: мы создаем объект, передаем его в immer, immer создает копию изначального объекта, которую мы и изменяем, и возвращает immer нам отредактированную копию изначального объекта, который теперь является immutable (неизменяемым) -->

<!-- код создания иммутабельного объекта -->
<!-- 
import produce from 'immer'
const state = { numbers: [1,2,4]};
const newState = produce(state, draft => {
	draft.numbers.push(4,5,6);
})
// { numbers: [1,2,3,4,5,6] }
 -->

<!--этот код по шагам -->
<!-- импортируем библиотеку immer и называем ее produce   -->
<!-- создаем интересующий нас state -->
<!-- передаем state в produce -->
<!-- после этого immer позволяет производить изменения в копии (в черновом варианте) этого объекта (draft.numbers) -->
<!-- мы пушим в массив numbers цифры 4,5,6 -->
<!-- теперь у нас есть иммутабельный стейт: newState.numders: [1,2,3,4,5,6] -->

																															<!-- Типизация селекторов-->
<!-- Селекторы (их state) не типизировались автоматически, потому что state в селекторах и state из cartSlice это разные вещи. state в селекторе - это глобальный state, в котором содержатся все остальные: cart, filter, pizza. Потому что мы его получаем от useSelector, а он возвращает весь state со всеми reducer. И внутри него уже есть state.cart, который равер state из cartSlise-->

																															<!-- Типизация configureStore-->
<!-- https://redux-toolkit.js.org/usage/usage-with-typescript -->

<!-- 
 Выдержка из документации RTK:
 если вы решите не создавать rootReducer самостоятельно, а вместо этого передать slice reducers непосредственно в configureStore(), вам нужно немного изменить типизацию, чтобы правильно определить корневой редуктор:
 -->
 <!-- Для этого добавляем в конце файла stoer.ts -->

<!-- 
export type RootState = ReturnType<typeof store.getState>
 -->

 <!-- Разбираемся что это: -->
 <!-- создаем и экспортируем тип RootState -->
 <!-- RootState - так мы сами называем тип, чтобы не возникало путаницы, т.к. просто state много где используется -->
<!-- RootState содержит тип всего нашего глобального state. В нем содержится типизация каждого reducer (filter, cart, pizza). states всех reducer будут находиться внутри RootState. Как мы это получили? -->
<!-- export type RootState = ReturnType<typeof store.getState> -->
<!-- store - это наша переменная store. Она хранит все state, а также subscribe, dispatch и многое другое - т.е. все что у нас есть в редаксе -->

<!-- 
export const store = configureStore({
	reducer: {
		filter: filterReducer,
		cart: cartReducer,
		pizzas: pizzasReducer,
	},
});
 -->
<!-- И мы вытаскиваем из всего редакса js-функцию getState -->
<!-- 
store.getState
 -->
<!-- store.getState вернет нам весь state -->
<!-- Но мы не вызываем store.getState. Не ставим (). Вместо этого мы используем typeof, который вернет нам тип функции store.getState -->
<!-- typeof store.getState -->

<!-- если мы эту строчку присвоим переменной то увидим, что в ней хранится такая стрелочная функция. т.е. просто весь тип state внутри тела функции -->

<!-- 
{
	()=> {
    filter: {
        sortType: {
            name: string;
            sortProperty: string;
        };
        activeCategory: number;
        currentPage: number;
        searchValue: string;
    };
    cart: CartSliceState;
    pizzas: {
        items: never[];
        status: string;
    };
	}
 -->

 <!-- Но глобальный state не является функцией. Мы же никогда не вызываем его чтобы получить из него данные, типа state().filter - Такого нет -->
 <!-- Теперь чтобы вытащить из функции ее тело мы используем ReturnType .
 
  ReturnType - условный тип, существующий в TS (получить тип значения, возвращаемого функцией). Он говорит: дай мне любую функцию и я ее содержимое превращу в тип.
	
	 (Условный тип ReturnType<T> служит для установления возвращаемого из функции типа. В качестве параметра типа должен обязательно выступать функциональный тип. На практике очень часто требуется получить тип, к которому принадлежит значение, возвращаемое из функции. Единственное, на что стоит обратить внимание, что в случаях, когда тип возвращаемого из функции значения является параметром типа, у которого отсутствуют хоть какие-то признаки, то тип ReturnType<T> будет представлен пустым объектным типом {}.)-->

<!-- export type RootState = ReturnType<typeof store.getState> -->

<!-- Теперь в RootState содержится следующий объект -->

<!-- 
type RootState = {
    filter: {
        sortType: {
            name: string;
            sortProperty: string;
        };
        activeCategory: number;
        currentPage: number;
        searchValue: string;
    };
    cart: CartSliceState;
    pizzas: {
        items: never[];
        status: string;
    };
}
 -->
<!-- Тип RootState конечно можно прописать вручную, что уже не просто, т.к. придется кучу всего импортировать, но если state будет расширяться, дополнятся вносить изменения придется также вручную и в RootState, а у нас все сейчас делается автоматически встроенными средствами RTK -->


																															<!-- Типизация селекторов продолжение-->

<!-- Теперь мы можем спокойно типизировать селекторы -->
<!-- Импортируем RootState -->
<!-- 
import { RootState } from '../store';
 -->
<!-- Говорим что тип глобального state - это RootState, и все отлично, id в нашем случае - это string -->
<!-- 
export const selectorCart = (state: RootState) => state.cart;
export const selectorCartItemById = (id: string) => (state: RootState) => state.cart.items.find((obj) => obj.id === id);
 -->

<!-- в filterSlice -->
<!-- export const selectorSort = (state: RootState) => state.filter.sortType; -->

<!-- в pizzaSlice -->
<!-- 
export const selectorFilter = (state:RootState) => state.filter
export const selectorPizzas = (state:RootState) => state.pizzas
  -->

<!-- ========================================================================================================================================== -->
																															<!-- Типизация createSlice (экшенов) -->
<!-- документация (https://redux-toolkit.js.org/usage/usage-with-typescript) -->
<!-- импотрируем из редакса тип PayloadAction -->
<!-- import { PayloadAction, createSlice } from '@reduxjs/toolkit'; -->
<!-- Далее нужно внутри <> указать какой тип хранит payload(/какой тип мы хотипм от него получить) -->
<!-- например -->
<!-- 
		minusItem(state, action: PayloadAction<string>) {
 -->
 <!-- 
 		addItem(state, action: PayloadAction<TCartItem>) {
  -->
<!-- 
		removeItem(state, action: PayloadAction<string>) {
 -->
 <!-- !!!Чтобы узнать что хранит экшн нужно идти в место где вызывается функция и смотреть что она передает!!! -->

<!-- Типизируем заодно объект item в PizzaBlock, скажем что он как и payload имеет тип TCartItem. Чтобы мы 100% отправляели то что ожидаем получить. -->

<!-- Экспортируем TCartItem -->
<!-- 
 export type TCartItem = {
	id: string;
	title: string;
	price: number;
	imageUrl: string;
	size: number;
	type: string;
	count: number;
};
 -->

<!-- импоритируем его в PizzaBlock -->
<!-- import { TCartItem, addItem, selectorCartItemById } from '../../redux/slices/cartSlice'; -->

<!-- Типизируем item -->
<!-- 
	const onClickAddItem = () => {
		const item: TCartItem = {
			id,
			title,
			price,
			imageUrl,
			size: sizes[activeSize],
			type: typeNames[activeType],
			count: 0,
		};
 -->


																															<!-- Быстрая типизация объектов с однотипными данными -->
<!-- Если у нас есть объек, у которого все ключи имеют одинаковый тип, и все значения имеют одинаковый тип, то типизацию такого объекта можно сократить -->
<!-- Для этого используется тип Record -->
<!-- например -->

<!-- type FetchAsyncArgs = Record<string, number>; -->

<!-- тут все ключи - это строки, все значания числа -->
<!-- Если хоть в одном месте тип не совпадает - нужно писать полностью -->

<!-- ========================================================================================================================================== -->

																															<!-- Типизация createAsyncThunk -->

<!-- Мы тут можем типизировать аргументы асинхронной функции - делаем это как обычно. И ответ, который мы получаем от сервера - для этого используем ключевое слово "as" и указыаем необходимый тип. В нашем случае - это массив объектов пицц, тип объекта из этого массива у нас уже есть - это PizzaItem -->

<!-- 
type FetchAsyncArgs = Record<string,string>;

export const fetchPizzasFromRedux = createAsyncThunk(
	'pizzas/fetchPizzasFromReduxStatus',

	async (params: FetchAsyncArgs, thunkAPI) => {
		const { category, sort, order, filter, currentPage } = params;
		const { data } = await axios.get(
			`https://64845cf9ee799e3216269459.mockapi.io/items?${category}&sortBy=${sort}&order=${order}&filter=${filter}&page=${currentPage}&limit=4`,
		);

		if (data.length === 0) {
			return thunkAPI.rejectWithValue('Питсы пустые');
		}
		return thunkAPI.fulfillWithValue(data) as PizzaItem[];
	},
);

type PizzaItem = {
	id: string;
	title: string;
	price: number;
	imageUrl: string;
	sizes: number[];
	types: number[];
};

 -->

<!-- Можно того же результата достичь по-другому. А именно сразу задать типы в <> во время вызова createAsyncThunk (1 идет тип возвращаемого значения, следующие - типы параметров) -->
<!-- Если с зажатым ctrl кликнуть на createAsyncThunk увидим ее код, где Returned - это возвращаемое значение, ThunkArg - аргументы функции. -->
<!-- 
    <Returned, ThunkArg = void>(typePrefix: string, payloadCreator: AsyncThunkPayloadCreator<Returned, ThunkArg, CurriedThunkApiConfig>, options?: AsyncThunkOptions<ThunkArg, CurriedThunkApiConfig>): AsyncThunk<Returned, ThunkArg, CurriedThunkApiConfig>;
 -->

<!-- 
export const fetchPizzasFromRedux = createAsyncThunk<PizzaItem[],Record<string,string>>(
	'pizzas/fetchPizzasFromReduxStatus',

	async (params, thunkAPI) => {
		const { category, sort, order, filter, currentPage } = params;
		const { data } = await axios.get(
			`https://64845cf9ee799e3216269459.mockapi.io/items?${category}&sortBy=${sort}&order=${order}&filter=${filter}&page=${currentPage}&limit=4`,
		);

		if (data.length === 0) {
			return thunkAPI.rejectWithValue('Питсы пустые');
		}
		return thunkAPI.fulfillWithValue(data);
	},
);
 -->

 <!-- Работать все будет так же, но если тут навести на data, то в подсказке выплывет, что data до сих пор any -->
<!-- Поэтому мы дополнительно типизируем data-->

<!-- Если кликнуть с зажатым ctrl на axios.get, то увидим такую строку -->
<!-- 
  get<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
 -->
 <!-- где первый аргумент это T - это любой тип, и эта переменная используется потом в AxiosResponse в качестве значения для data  -->

<!-- 
export interface AxiosResponse<T = any, D = any> {
  data: T;
  status: number;
  statusText: string;
  headers: RawAxiosResponseHeaders | AxiosResponseHeaders;
  config: InternalAxiosRequestConfig<D>;
  request?: any;
}
 -->

<!-- Значит указываем тип для первого аргумента функции get -->

 <!-- 
 		const { data } = await axios.get<PizzaItem[]>(
  -->

<!-- В итоге так: -->
<!-- 
export const fetchPizzasFromRedux = createAsyncThunk<PizzaItem[],Record<string,string>>(
	'pizzas/fetchPizzasFromReduxStatus',

	async (params, thunkAPI) => {
		const { category, sort, order, filter, currentPage } = params;
		const { data } = await axios.get<PizzaItem[]>(
			`https://64845cf9ee799e3216269459.mockapi.io/items?${category}&sortBy=${sort}&order=${order}&filter=${filter}&page=${currentPage}&limit=4`,
		);

		if (data.length === 0) {
			return thunkAPI.rejectWithValue('Питсы пустые');
		}
		return thunkAPI.fulfillWithValue(data);
	},
);
 -->

<!-- ========================================================================================================================================== -->
<!-- 49:00 -->
																															<!-- Типизация extraReducers -->
<!-- Все будет типизировано автоматически, если до него все правильно типизировть -->
<!-- 
	extraReducers: (builder) => {
		builder
			.addCase(fetchPizzasFromRedux.pending, (state) => {
				state.status = 'loading';
				state.items = [];
			})
			.addCase(fetchPizzasFromRedux.fulfilled, (state, action) => {
				state.items = action.payload;
				state.status = 'success';
			})
			.addCase(fetchPizzasFromRedux.rejected, (state, action) => {
				state.status = 'error';
				state.items = [];
			});
	},
}
 -->

																															<!-- Enum -->
<!-- Это аналого объекта для TS. Чтобы вместо типа указать enum, и переиспользовать код -->
<!-- Нельзя просто создать переменную, записать в нее объект и использовать ее в interface и вообще в TS, нельзя использовать объекты без конвертации в тип. -->
<!-- Чтобы создать enum так и пишем ключевое слово enum , потом даем ему имя как любой переменной с БОЛЬШОЙ БУКВЫ, дальше без "равно" пишем {}
и указываем пары ключ значение, только с помощью "=" , перечисляем запятыми. Ключи принято указыать uppercase, значение можно писать как угодно -->

<!-- например -->
<!-- 
enum Status {
	LOADING = 'loading',
	SUCCESS = 'success',
	ERROR = 'error',
}
 -->

 <!-- теперь типизируем interface по другому -->
<!-- 
interface IPizzaSliceState {
	items: PizzaItem[];
	status: Status;
}
 -->

<!-- Меняем строковые статусы на значения из enum -->
<!-- 
	extraReducers: (builder) => {
		builder
			.addCase(fetchPizzasFromRedux.pending, (state) => {
				state.status = Status.LOADING;
				state.items = [];
			})
			.addCase(fetchPizzasFromRedux.fulfilled, (state, action) => {
				state.items = action.payload;
				state.status = Status.SUCCESS;
			})
			.addCase(fetchPizzasFromRedux.rejected, (state, action) => {
				state.status = Status.ERROR;
				state.items = [];
			});
	},
 -->

<!--Теперь можно менять значения ключей внутри enum и автоматически будет меняться ожидаемые данные у тех сущностей, которые его используют -->

<!-- По факту в enum в нашем случае передается просто строчка, и в браузере мы получим тот же результат если воспользуемся обычным объектом. -->

																															<!-- Getting the Dispatch type -->
<!-- 1:00:00 -->
<!-- ========================================================================================================================================== -->
<!-- ========================================================================================================================================== -->
<!-- ========================================================================================================================================== -->
<!-- ========================================================================================================================================== -->
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)
